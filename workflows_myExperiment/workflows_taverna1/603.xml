<?xml version="1.0" encoding="UTF-8"?>
<s:scufl xmlns:s="http://org.embl.ebi.escience/xscufl/0.1alpha" version="0.2" log="0">
  <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:6d770ac3-7f27-4fc9-a98d-ae4f49522b6b" author="Ingo Wassink Han Rauwerda, Pieter Neerincx, Paul van der Vet, Anton Nijholt, Timo Breit, Jack Leunissen" title="Mapping OligoNucleotides to an assembly" />
  <s:processor name="BlastHitsFinished_Filename" boring="true">
    <s:stringconstant>BlastHitsFinished.txt</s:stringconstant>
  </s:processor>
  <s:processor name="BioMartReport_Filename" boring="true">
    <s:stringconstant>BioMartReport.txt</s:stringconstant>
  </s:processor>
  <s:processor name="OligosNotFound_Filename" boring="true">
    <s:stringconstant>OligosNotFound.txt</s:stringconstant>
  </s:processor>
  <s:processor name="BlastReport_Filename" boring="true">
    <s:stringconstant>BlastReport.txt</s:stringconstant>
  </s:processor>
  <s:processor name="GeneratePlots">
    <s:rshell s:hostname="localhost" s:port="6311" s:username="" s:password="" s:keepSessionAlive="false">
      if(FALSE){
  # if it should be executed outside RShell
  blastresultfile &lt;- "BlastReport.txt"
  biomartfile &lt;- "BioMartReport.txt"

  Classes &lt;- "classes.txt"
  Report &lt;-  "report.txt"
  BarPlot &lt;-  "barplot.pdf"
  printDevice &lt;- pdf
} else{
  printDevice &lt;- png
}

##MODIFY THESE PARAMETERS###########################################################
eval_threshold = 1e-12;
span_threshold = 57;


debug = 0;

####################################################################################

result.table &lt;- c("oligo", "gene", "class")
#classes
#1~single hit approved
#2~mulithit single transcript single gene approved on span only
#3~mulithit single transcript single gene approved on e-value for single stretch, possibly intron spanning
#4~mulithit single transcript single gene approved on e-value for single stretch, no intron spanning
#5~multihit multiple transcripts single gene approved on span only
#6~multihit multiple transcripts single gene approved on e-value for single stretch, possibly intron spanning
#7~multihit multiple transcripts single gene approved on e-value for single stretch, no intron spanning
#8~hit discarded
#9~mulithit single transcript single gene discarded, no intron spanning
#10~mulithit multiple transcript single gene discarded, no intron spanning
#11~multi gene hit discarded
#12~no transcript found but minimum e-value below threshold
#13~no transcript found and discard on e-value above threshold
#14~single hit below the e-value threshold + hit below the e-value threshold on assembly without transcript


classchart &lt;- rep(0,14)
names(classchart)&lt;-c("class 1", "class 2","class 3","class 4","class 5","class 6","class 7","class 8","class 9","class 10","class 11","class 12","class 13","class 14")
nms&lt;-c("1 - single hit within specs"
,"2 - mulithit single transcript single gene approved on span only"
,"3 - mulithit single transcript single gene approved on e-value, possibly intron spanning"
,"4 - mulithit single transcript single gene approved on e-value for single stretch, no intron spanning"
,"5 - multihit multiple transcripts single gene approved on span only"
,"6 - multihit multiple transcripts single gene approved on e-value for single stretch, possibly intron spanning"
,"7 - multihit multiple transcripts single gene approved on e-value for single stretch, no intron spanning"
,"8 - hit outside specs"
,"9 - mulithit single transcript outside specs"
,"10 - mulithit multiple transcript outside specs"
,"11 - multi gene hit"
,"12 - no transcript found but hit found within specs"
,"13 - no transcript found, hits outside specs"
,"14 - single hit below the e-value threshold + hit below the e-value threshold on assembly without transcript"
)

classeleven&lt;-matrix(0,ncol=2,nrow=1)

#oligo.res[,1]: "blasthitidx"
#oligo.res[,2]	"oligoid.x"
#oligo.res[,3]	"contig"
#oligo.res[,4]	"percid"
#oligo.res[,5]	"stretch"
#oligo.res[,6]	"mm"
#oligo.res[,7]	"gap"
#oligo.res[,8]	"qstart"
#oligo.res[,9]	"qstop"
#oligo.res[,10]	"dstart"
#oligo.res[,11]	"dstop"
#oligo.res[,12]	"eval"
#oligo.res[,13]	"bitscore"
#oligo.res[,14]	"index"
#oligo.res[,15]	"oligoid.y"
#oligo.res[,16]	"gene"
#oligo.res[,17]	"transcript"
#oligo.res[,18]	"startT"
#oligo.res[,19]	"stopT"


##FUNCTIONS#########################################################################
intronspanfunc &lt;- function(oligo.res) {
	span &lt;- 0;
	intronspan &lt;- 0;
	approv &lt;- 0;
	#for intron spanning it is required that oligo hits target whithout overlap
	d &lt;- c(oligo.res[1,10]:oligo.res[1,11]);
#	print(paste("d:",d))
#	print(paste("oligo:",as.character(oligo.res[1,2])))
	a &lt;- oligo.res[1,]
	if(dim(oligo.res)[1] &gt;1){
		for (ii in 2:length(oligo.res[,1])) {
			if (length(intersect(c(oligo.res[ii,10]:oligo.res[ii,11]),d)) == 0) {
				a&lt;- rbind(a,oligo.res[ii,])
				#print(paste("intersect:",intersect(c(oligo.res[ii,10]:oligo.res[ii,11]),d)))
				d&lt;- c(d,c(oligo.res[ii,10]:oligo.res[ii,11]))
			}
		}
	}
	a&lt;- oligo.res[order(a[,8]),]	
	overlap &lt;- 0
	span &lt;- a[1,9]-a[1,8] +1 ;
#	print(paste("span binnen a: ", span))
#	print(a)
	for (ii in 1:length(a[,1])) {
#		print(paste("A:",a[ii,8:11]))
		if (ii &gt; 1  ) {  
			overlap &lt;- a[ii,8] - a[ii-1,9] -1 ;
			if (overlap &gt;= 0) {  #to avoid negative overlaps
			span &lt;- span + a[ii,9] - a[ii,8] + 1 - overlap;}
			#print(paste("span binnen a: ", span))
		}
	}
#	print(paste("SPAN: ", span));

	ret &lt;-c(span);
	ret;
}


getresfunc &lt;- function(oligo.res) {
	#function to determine if there exist hits with a mapping below eval_threshold and if exist non-mapping hits below eval_threshold
	transcript_complies &lt;- 0;
	non_transcript_compliance &lt;- 0;
	for (ii in 1 : length(oligo.res[,1])){
		if (!is.na(oligo.res[ii, 17]) &amp; oligo.res[ii,12] &lt; eval_threshold){
			transcript_complies &lt;- 1;
		}
		if (oligo.res[ii,12] &lt; eval_threshold &amp; is.na(oligo.res[ii, 17])) {
			non_transcript_compliance &lt;- 1;
		}
	}
	ret &lt;-c(transcript_complies,non_transcript_compliance)
	ret;
}


##MAIN##############################################################################

start &lt;- as.numeric(Sys.time());

blast_result &lt;- read.csv(file = blastresultfile, header = TRUE, sep ="\t", row.names=NULL, col.names=c("oligoid","contig","percid","stretch", "mm","gap","qstart","qstop","dstart","dstop","eval","bitscore","blasthitidx", "index"));
biomart_result &lt;- read.csv(file = biomartfile, header = TRUE, sep = "\t", row.names=NULL, col.names=c("oligoid","blasthitidx","gene","transcript","startT","stopT"))

no.of.lines &lt;- length(blast_result[,1])

ens_result &lt;- merge(blast_result, biomart_result, by="blasthitidx",all.x = TRUE) 

write.table(ens_result, file="ens_result.txt", sep = "\t", row.names=F)

lev &lt;- levels(ens_result[,2])
no.of.levels &lt;- length(lev)

for (i in 1 : (no.of.levels ) ){
	oligo.res = subset(ens_result,ens_result[,2]==lev[i])
	x &lt;- dim(oligo.res);
	curr &lt;- as.numeric(Sys.time());
	print(paste("Subset no. ", i, "/" ,no.of.levels, "from", blastresultfile , "oligo:", lev[i], "#hits:" , x[1], "idx:", oligo.res[1,1], round(((start-curr)/60),0), " - gene: ", oligo.res[,16],  " - transcr.: ", oligo.res[,17]," - eval: ", oligo.res[,12] ));
	tot.res &lt;- NULL;

	NoH &lt;- length(na.omit(oligo.res[,17]));
	NoTf &lt;- length(unique(na.omit(oligo.res[,17])));		
	NoG &lt;- length(unique(as.vector(na.omit(oligo.res[,16]))));

	if (NoTf == 0) {
		if ( min(as.numeric(oligo.res[,12])) &lt;= eval_threshold) {
			class &lt;- 12;
			classchart[12] &lt;- classchart[12]+1
			result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),"NA", class));
			if (debug) {print(paste("QUESTIONABLE ", oligo.res[1,2], " - NO TRANSCRIPT FOUND BUT HIT BELOW  e-VALUE THRESHOLD"));}
		}
		if ( min(as.numeric(oligo.res[,12])) &gt; eval_threshold) {
			class &lt;- 13;			
			classchart[13] &lt;- classchart[13]+1
			result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),"NA", class));
			if (debug) {print(paste("DISCARD ", oligo.res[1,2], " - NO TRANSCRIPT FOUND AND HIT(S) ABOVE  e-VALUE THRESHOLD"));}
		}
	}

	if(NoTf &gt; 0) {
		levels(oligo.res) &lt;- factor(as.character(oligo.res[,17])) #per transcript
		if (debug) {print(paste ("RESULT FOR ",oligo.res[1,2]));}

		#Multi Gene Class:
		if (NoG &gt;1) { 
			glev &lt;- levels(factor(as.character(oligo.res[,16]))) #gene level
			no.of.glev &lt;- length(glev)
			res &lt;- getresfunc(oligo.res)
			
			gene.w.approv.tr &lt;- 0;

			#look at all genes in this set: 
			#each can be multihit multi transcripts, second loop is by transcript level on gene level
#			if (debug) {print (paste(no.of.trlev, " levels " , trlev));}
			for (y in 1 : ( no.of.glev ) ){
				rsl &lt;- 0;
				isp &lt;-0;
				ispanmt &lt;- 0;			
				ntc &lt;- res[2]
				hitspan &lt;-0
				hiteval &lt;-0
				hitspaneval &lt;-0
				g.sub = subset(oligo.res,oligo.res[,16]==glev[y])
				#look if there is any non-transcript hit below e-value threshold
				gres &lt;- getresfunc(g.sub)			
				ntc &lt;- gres[2]
				trlev &lt;- levels(factor(as.character(g.sub[,17])))
				no.of.trlev &lt;- length(trlev)
				for (yy in 1 : (no.of.trlev ) ){
					tr.sub = subset(g.sub,g.sub[,17]==trlev[yy])
					#print(paste("Dimension tr.sub:",dim(tr.sub)[1]))
					span&lt;-intronspanfunc(tr.sub);
					if (span &gt; span_threshold) {isp =1} 
					res.lev &lt;- getresfunc(tr.sub)
					if (res.lev[1] == 1) {rsl &lt;- 1} # transcript complient
					if (debug) {print(paste("span, isp and rsl: ", span," ",isp," ",rsl))}
#						hitspaneval &lt;- 1 
#						break
				if (hitspan ==0 &amp; isp ==1 ) {hitspan &lt;-1}
				if (hiteval == 0 &amp; rsl == 1 ) {hiteval &lt;- 1}
				}
				if (hitspan ==1 | hiteval == 1 ) {
					gene.w.approv.tr &lt;- gene.w.approv.tr +1
				}		
			}

			if (debug) {print(paste(gene.w.approv.tr, "MULTI GENE BELOW THRESHOLDS"))}
			
			if(gene.w.approv.tr &gt; 1 ) {
				print(paste(gene.w.approv.tr, "MULTI GENE BELOW THRESHOLDS - II"))
				if (debug) {print(paste("DISCARD " , oligo.res[1,2], " ", NoG, " GENES FOUND"));}
				class &lt;- 11;
				classchart[11] &lt;- classchart[11]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),"NA", class));

			}

			if ( gene.w.approv.tr  == 0 &amp; ntc ==1 ) { 
				class &lt;- 12;
				classchart[12] &lt;- classchart[12]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("Q " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - Multiple GENEs: probe only approved on e-value of hit without a transcript annotation"))}
			}

			if ( gene.w.approv.tr  == 0 &amp; ntc == 0 ) { 
				class &lt;- 8;
				classchart[8] &lt;- classchart[8]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),"NA", class));
				if (debug) {print (paste("DISCARD " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - Multiple GENEs: hit below specs"))}
			}

			if ( gene.w.approv.tr  == 1 &amp; ntc == 0 ) { 
				class &lt;- 3;
				classchart[3] &lt;- classchart[3]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),"NA", class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - Multiple GENEs: one gene with approved transcript"))}
			}

			
			if ( gene.w.approv.tr  == 1 &amp; ntc ==1 ) { 
				class &lt;- 14;
				classchart[14] &lt;- classchart[14]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("Q " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - Multiple GENEs: probe hits at least one annotated transcript but also has of hit without a transcript annotation"))}
			}
	
		}
		
		#Single Hit Class:
		if (debug) {print(paste("Number of Different Hits found " , NoH));}
		if (NoH == 1 ) {
			res &lt;- getresfunc(oligo.res)
			transcript_complies &lt;- res[1]
			non_transcript_compliance &lt;- res[2]
			if (transcript_complies == 1 &amp; non_transcript_compliance == 0) {
				class &lt;- 1;
				classchart[1] &lt;- classchart[1]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print(paste("APPROVE ", oligo.res[1,2], " - single hit below the e-value threshold", as.vector(oligo.res[1,16]), as.vector(oligo.res[1,17])));}
			}
			if (transcript_complies == 1 &amp; non_transcript_compliance == 1) {
				class &lt;- 14;
				classchart[14] &lt;- classchart[14]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print(paste("Q ", oligo.res[1,2], " - single hit below the e-value threshold + hit on assembly without transcript"));}
			}
			if (transcript_complies == 0 &amp; non_transcript_compliance == 1) {
				class &lt;- 12;
				classchart[12] &lt;- classchart[12]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),"NA", class));
				if (debug) {print(paste("QUESTIONABLE ", oligo.res[1,2], " - NO TRANSCRIPT BELOW e-VALUES THRESHOLD FOUND BUT HIT BELOW  e-VALUE THRESHOLD"));}
			}
			if (transcript_complies == 0 &amp; non_transcript_compliance == 0) {
				class &lt;- 8;
				classchart[8] &lt;- classchart[8]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
			}
		}

		#Multiple hit, single transcript class
		isp &lt;- 0;
		approv &lt;- 0;
		if (NoTf == 1 &amp; NoH &gt; 1 &amp; NoG &lt;= 1){
			if (debug) {print ("MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE");}

			span &lt;- intronspanfunc(oligo.res);
			if (span &gt; span_threshold) {isp =1} 
			res &lt;- getresfunc(oligo.res)
			transcript_complies &lt;- res[1]
			non_transcript_compliance &lt;- res[2]

			if ( isp ==1 &amp; transcript_complies ==0 &amp; non_transcript_compliance ==0) {
				class &lt;- 2;
				classchart[2] &lt;- classchart[2]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE: ON SPAN (POSSIBLY INTRON SPANNING) probe could not be approved on single e-value"))}
			}
			if ( isp == 1 &amp; transcript_complies ==1 &amp; non_transcript_compliance ==0 ) {
				class &lt;- 3;
				classchart[3] &lt;- classchart[3]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE: ON SINGLE e-VALUE - POSSIBLY INTRON SPANNING"));}
			}
			if ( isp == 0 &amp; transcript_complies ==1 &amp; non_transcript_compliance ==0 ) {
				class &lt;- 4;
				classchart[4] &lt;- classchart[4]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE: no intron spanning, single e-value below threshold"))}
			}

			if ( transcript_complies ==1 &amp; non_transcript_compliance ==1 ) {
				class &lt;- 14;
				classchart[14] &lt;- classchart[14]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE: ON SINGLE e-VALUE - POSSIBLY INTRON SPANNING + hit on assembly without transcript"));}
			}
			if ( transcript_complies ==0 &amp; non_transcript_compliance ==1 ) {
				class &lt;- 12;
				classchart[12] &lt;- classchart[12]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE: ON SINGLE e-VALUE hit on assembly without transcript"));}
			}

			if ( isp ==0 &amp; transcript_complies ==0 &amp; non_transcript_compliance ==0) {
				class &lt;- 9;
				classchart[9] &lt;- classchart[9]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("DISCARD " , oligo.res[1,2], " MULTIHIT SINGLE TRANSCRIPT - SINGLE GENE: NO INTRON SPANNING AND NO SINGLE e-VALUE BELOW THRESHOLD"))}
			}
		}


		#Multiple hit, multiple transcript class
		if (NoTf &gt; 1 &amp; NoH &gt; 1 &amp; NoG &lt;= 1){
			if (debug) {print ("MULTIHIT MULTIPLE TRANSCRIPTS - SINGLE GENE");}
			trlev &lt;- levels(factor(as.character(oligo.res[,17])))
			no.of.trlev &lt;- length(trlev)
			rsl &lt;- 0;
			ispanmt &lt;- 0;
			#look if there is any non-transcript hit below e-value threshold
			res &lt;- getresfunc(oligo.res)			
			transcript_complies &lt;- res[1]
			ntc &lt;- res[2]
			hitspan &lt;-0	# 1 if any of the transcript hit classes has span above span_threshold
			hiteval &lt;-0	# 1 if any of the transcript hit classes has eval below eval_threshold
			hitspaneval &lt;-0 # 1 if any of the transcript hit classes has span above span_threshold and eval below eval_threshold

			if (debug) {print (paste(no.of.trlev, " levels " , trlev));}
			for (y in 1 : (no.of.trlev ) ){
				tr.sub = subset(oligo.res,oligo.res[,17]==trlev[y])
				print ("SUBLEVEL:");
				print(tr.sub);
				print(paste("Dimension tr.sub:",dim(tr.sub)))
				span&lt;-intronspanfunc(tr.sub);
				if (span &gt; span_threshold) {isp =1} 
				res.lev &lt;- getresfunc(tr.sub)
				if (res.lev[1] == 1) {
					rsl &lt;- 1
					if (debug) {print(paste("span, isp and approv: ", span," ",isp," ",rsl))}
					#if there is any hit in this transcript class below e-value threshold, stop the loop
					if (isp == 1) {
						hitspaneval &lt;- 1 
						break
					}
				}
				if (hitspan ==0 &amp; isp ==1 ) {hitspan &lt;-1}
				if (hiteval == 0 &amp; rsl == 1 ) {hiteval &lt;- 1}		
			}

			if ( hitspan == 1 &amp; hiteval == 0 &amp; hitspaneval == 0 &amp; ntc ==0 ) { 
				class &lt;- 5;
				classchart[5] &lt;- classchart[5]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - SINGLE GENE: ON SPAN (POSSIBLY INTRON SPANNING) probe could not be approved on single e-value"))}
			}

			if ( hitspaneval == 1 &amp; ntc ==0 ) { 
				class &lt;- 6;
				classchart[6] &lt;- classchart[6]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - SINGLE GENE:  INTRON SPANNING + probe approved on e-value"))}
			}

			if ( hitspan == 0 &amp; hiteval == 1 &amp; hitspaneval == 0 &amp; ntc ==0 ) { 
				class &lt;- 7;
				classchart[7] &lt;- classchart[7]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("APPROVE " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - SINGLE GENE: POSSIBLY INTRON SPANNING but probe only approved on e-value"))}
			}
			if ( hitspan == 0 &amp; hiteval == 0 &amp; hitspaneval == 0 &amp; ntc ==1 ) { 
				class &lt;- 12;
				classchart[12] &lt;- classchart[12]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("Q " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - SINGLE GENE: probe only approved on e-value of hit without a transcript annotation"))}
			}
			if ( (hitspan == 1 | hiteval == 1 | hitspaneval == 1 ) &amp; ntc ==1 ) { 
				class &lt;- 14;
				classchart[14] &lt;- classchart[14]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("Q " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - SINGLE GENE: probe hits at least one annotated transcript but also has of hit without a transcript annotation"))}
			}
			if ( hitspan == 0 &amp; hiteval == 0 &amp; hitspaneval == 0  &amp; ntc == 0 ) { 
				class &lt;- 10;
				classchart[10] &lt;- classchart[10]+1
				result.table &lt;- rbind(result.table, c(as.vector(oligo.res[1,2]),as.vector(oligo.res[1,16]), class));
				if (debug) {print (paste("DISCARD " , oligo.res[1,2], " MULTIHIT MULTIPLE TRANSCRIPT - SINGLE GENE: probe hits not below thresholds"))}
			}
		}
	}
	print(paste("CLASS is: " ,class));
	#print(paste("Number of genes: ",length(unique(as.vector(oligo.res[,14])))));
	if (debug) {print("++++++++++++++++++++++++++++++++++++++++++++++++++++++++");}
}

write.table(result.table, file = Report, sep = "\t", row.names = FALSE, col.names = FALSE)

classchartTable &lt;- cbind(as.data.frame(classchart), round(100*classchart/sum(classchart), digits=1))
write.table(classchartTable, file = Classes,  sep = "\t", col.names = FALSE)

if(!exists("oligosnotfound")){
  oligosnotfound &lt;- c()
}

##Visualizations:
classchart_rel = c(length(oligosnotfound), as.vector(classchart)[1:14])
classchart_rel = 100*classchart_rel/sum(classchart_rel)

printDevice(BarPlot)
barplot(classchart_rel, names=c(1:length(classchart_rel))-1, 
        main="Relative distribution of probes among the classes",
        xlab="Classes", 
		ylab="% of probes", col=rainbow(length(classchart_rel)))
dev.off()



print(paste("This run took " , round(((as.numeric(Sys.time()) - start)/60),0), " minutes"));


####################################################################################
      <s:rshellInputPortList>
        <s:rshellInputPort s:syntacticType="l('text/plain')" s:symanticType="STRING_LIST">oligosNotFound</s:rshellInputPort>
        <s:rshellInputPort s:syntacticType="'text/plain'" s:symanticType="TEXT_FILE">blastresultfile</s:rshellInputPort>
        <s:rshellInputPort s:syntacticType="'text/plain'" s:symanticType="TEXT_FILE">biomartfile</s:rshellInputPort>
      </s:rshellInputPortList>
      <s:rshellOutputPortList>
        <s:rshellOutputPort s:syntacticType="'image/png'" s:symanticType="PNG_FILE">BarPlot</s:rshellOutputPort>
        <s:rshellOutputPort s:syntacticType="'text/plain'" s:symanticType="TEXT_FILE">Classes</s:rshellOutputPort>
        <s:rshellOutputPort s:syntacticType="'text/plain'" s:symanticType="TEXT_FILE">Report</s:rshellOutputPort>
      </s:rshellOutputPortList>
    </s:rshell>
  </s:processor>
  <s:processor name="Read_BlastReport">
    <s:local>net.sourceforge.taverna.scuflworkers.io.TextFileReader</s:local>
  </s:processor>
  <s:processor name="Create_Header_BlastReport" boring="true">
    <s:description>Processor to add content to a (existing)  file. The content is added to the end of the file.

The inputs:
Filename: the file name of a file, if the file does not exists, a new file is added
Content: the string to append
NewLine [default = true]: if true, a newline is added to the end of the line (useful if you want to add a record each time)</s:description>
    <s:defaults>
      <s:default name="Content">OligoId	Contig	Perc ID	Stretch	Kw1	Kw2	Qstart	Qstop	Dstart	Dstop	E-value	Score	BlastHitNr	Index</s:default>
    </s:defaults>
    <s:beanshell>
      <s:scriptvalue>import java.util.concurrent.Semaphore;

if(!Boolean.parseBoolean(Restart) &amp;&amp; new File(Filename).exists()){
  return;
}

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, false));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Restart</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist />
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Create_Semaphore" boring="true">
    <s:beanshell>
      <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}</s:scriptvalue>
      <s:beanshellinputlist />
      <s:beanshelloutputlist />
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Read_OligosNotFound">
    <s:local>net.sourceforge.taverna.scuflworkers.io.TextFileReader</s:local>
  </s:processor>
  <s:processor name="Chunk_Size" boring="true">
    <s:stringconstant>250</s:stringconstant>
  </s:processor>
  <s:processor name="Create_Header_BioMartReport" boring="true">
    <s:description>Processor to add content to a (existing)  file. The content is added to the end of the file.

The inputs:
Filename: the file name of a file, if the file does not exists, a new file is added
Content: the string to append
NewLine [default = true]: if true, a newline is added to the end of the line (useful if you want to add a record each time)</s:description>
    <s:defaults>
      <s:default name="Content">OligoId	Index	BlastHitNr	GenId	TranscriptId	TranscriptStart	TranscriptEnd</s:default>
    </s:defaults>
    <s:beanshell>
      <s:scriptvalue>import java.util.concurrent.Semaphore;

if(!Boolean.parseBoolean(Restart) &amp;&amp; new File(Filename).exists()){
  return;
}

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, false));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Restart</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist />
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Create_Sequence_Chunks">
    <s:defaults>
      <s:default name="chunkSize">7</s:default>
    </s:defaults>
    <s:beanshell>
      <s:scriptvalue>int size = Integer.parseInt(chunkSize);

List chunks = new ArrayList();
for(int index=0; index &lt; sequences.size(); index += size){
  Iterator iterator = sequences.subList(index, Math.min(sequences.size(), index+size)).iterator();
  StringBuffer stringBuffer = new StringBuffer();
  while(iterator.hasNext()){
    stringBuffer.append(iterator.next()).append("\n");
  }
  chunks.add(stringBuffer.toString());
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="l('text/plain')">sequences</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">chunkSize</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="l('text/plain')">chunks</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Touch_BlastHitsFinished_File" boring="true">
    <s:defaults>
      <s:default name="Content" />
      <s:default name="NewLine">false</s:default>
    </s:defaults>
    <s:beanshell>
      <s:scriptvalue>import java.util.concurrent.Semaphore;

if(!Boolean.parseBoolean(Restart) &amp;&amp; new File(Filename).exists()){
  return;
}

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, false));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Restart</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist />
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Split_Blast_Report">
    <s:beanshell>
      <s:scriptvalue>import java.io.BufferedReader;
import java.io.StringReader;

Map indexMap = new HashMap();

BufferedReader fileReader = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));
fileReader.readLine();
while((lineInFile = fileReader.readLine()) != null){
    String index = lineInFile.trim();
    if(index.length() &lt;= 0){
      continue;
    }

    indexMap.put(index, new Integer(1));
}
fileReader.close();

BufferedReader reader = new BufferedReader(new StringReader(BlastReport));
Records = new ArrayList();
String line;

// skip first line
reader.readLine();
while((line = reader.readLine()) != null){  
  String[] entries = line.split("\t");
  if(entries.length &lt;= 1){
    continue;
  }
  String index = entries[entries.length-1];
  if(!indexMap.containsKey(index)){
    Records.add(line);
  }
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">BlastReport</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">filename</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="l('text/plain')">Records</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Read_BioMartReport">
    <s:local>net.sourceforge.taverna.scuflworkers.io.TextFileReader</s:local>
  </s:processor>
  <s:processor name="Touch_OligosNotFound_File" boring="true">
    <s:description>Processor to add content to a (existing)  file. The content is added to the end of the file.

The inputs:
Filename: the file name of a file, if the file does not exists, a new file is added
Content: the string to append
NewLine [default = true]: if true, a newline is added to the end of the line (useful if you want to add a record each time)</s:description>
    <s:defaults>
      <s:default name="Content" />
      <s:default name="NewLine">false</s:default>
    </s:defaults>
    <s:beanshell>
      <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, false));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist />
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Filter_Sequences_For_Blast">
    <s:beanshell>
      <s:scriptvalue>import java.io.BufferedReader;
import java.io.StringReader;

Map idMap = new HashMap();


bsh.shared.blastReportIndex = 1;
BufferedReader fileReader = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));
fileReader.readLine();
while((lineInFile = fileReader.readLine()) != null){
    String[] fields = lineInFile.split("\t");
    if(fields.length &lt;= 1){
      continue;
    }
    idMap.put(fields[0], new Integer(1));
    bsh.shared.blastReportIndex = Math.max(bsh.shared.blastReportIndex, Integer.parseInt(fields[fields.length-1])+1);
}
fileReader.close();

BufferedReader reader = new BufferedReader(new StringReader(sequences));
StringBuffer sequencesToDoSB = new StringBuffer();
String line;
while((line = reader.readLine()) != null){  
  if(line.startsWith("&gt;")){
    String sequenceId = line.substring(1).trim();
    if(!idMap.containsKey(sequenceId)){
      sequencesToDoSB.append(line).append("\n")
                     .append(reader.readLine()).append("\n"); 
    }
  }
}


sequencesToDo = sequencesToDoSB.toString();

if(bsh.shared.blastReportIndex == void){
  bsh.shared.blastReportIndex = 1;
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">sequences</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">filename</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/plain'">sequencesToDo</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="Split_sequences">
    <s:beanshell>
      <s:scriptvalue>import java.io.BufferedReader;
import java.io.StringReader;

BufferedReader reader = new BufferedReader(new StringReader(sequenceText));

ArrayList sequences = new ArrayList();
String line;
while((line = reader.readLine()) != null){  
  if(line.trim().length() == 0){
    continue;
  }

  if(line.startsWith("&gt;")){
     line += "\n" + reader.readLine();
  }
  sequences.add(line);
}</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">sequenceText</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="l('text/plain')">sequences</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="DoBioMart" workers="8">
    <s:workflow maxretries="10" retrydelay="500" critical="true">
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:8c4d9af5-596a-4a31-9c3b-cf79a0693db9" author="" title="DoBioMart" />
        <s:processor name="Append_To_BioMartReport" workers="10">
          <s:description>Processor to add content to a (existing)  file. The content is added to the end of the file.

The inputs:
Filename: the file name of a file, if the file does not exists, a new file is added
Content: the string to append
NewLine [default = true]: if true, a newline is added to the end of the line (useful if you want to add a record each time)</s:description>
          <s:beanshell>
            <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, true));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist />
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Split_Blast_Record">
          <s:beanshell>
            <s:scriptvalue>String[] elements = blastRecord.trim().split("\t");

oligoId = elements[0];
contig = elements[1];
dstart = Integer.parseInt(elements[8]);
dstop = Integer.parseInt(elements[9]);
blastIndex = elements[elements.length-1];

int strand;
if(dstart &gt;= dstop){
  strand = -1;
  int tmp = dstart;
  dstart = dstop;
  dstop = tmp;
} else{
  strand = 1;
}

chromosomeRegion = contig + ":" + dstart + ":" + dstop + ":" + strand;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">blastRecord</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">oligoId</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">blastIndex</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">chromosomeRegion</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">dstart</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">dstop</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Add_OligoID_BlastIndex_Prefix">
          <s:beanshell>
            <s:scriptvalue>FullRecord = new ArrayList();

for(String record : BioMartRecord){
  FullRecord.add(OligoID + "\t" + BlastIndex + "\t" + record);
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">BioMartRecord</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">OligoID</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">BlastIndex</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="l('text/plain')">FullRecord</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:dot>
                <i:iterator name="OligoID" />
                <i:iterator name="BlastIndex" />
              </i:dot>
              <i:iterator name="BioMartRecord" />
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="Append_To_BlastHitsFinished_File">
          <s:beanshell>
            <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, true));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist />
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Flatten_list">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="CreateBioMartRecord_Iteration">
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:78a15815-6951-4231-9fa2-48ecbef4ea72" author="" title="Untitled workflow #83" />
              <s:processor name="Fail_if_false">
                <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfFalse</s:local>
              </s:processor>
              <s:processor name="Create_BioMart_Record">
                <s:beanshell>
                  <s:scriptvalue>record = new StringBuffer() .append(geneId).append("\t")
                           .append(transcriptId).append("\t")
                           .append(transcriptStart).append("\t")
                           .append(transcriptEnd).toString();</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">geneId</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">transcriptId</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">transcriptStart</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">transcriptEnd</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">record</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
                <s:iterationstrategy>
                  <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
                    <i:iterator name="geneId" />
                    <i:iterator name="transcriptId" />
                    <i:iterator name="transcriptStart" />
                    <i:iterator name="transcriptEnd" />
                  </i:dot>
                </s:iterationstrategy>
              </s:processor>
              <s:processor name="Fail_if_true">
                <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
              </s:processor>
              <s:processor name="EmptyList">
                <s:beanshell>
                  <s:scriptvalue>list = new ArrayList();</s:scriptvalue>
                  <s:beanshellinputlist />
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">list</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="checkIsInExon">
                <s:beanshell>
                  <s:scriptvalue>int dStart = Integer.parseInt(DStart);
int dStop = Integer.parseInt(DStop);

if(dStart &gt; dStop){
  int tmp = dStop;
  dStop = dStart;
  dStart = tmp;
}

eStart = Integer.parseInt(ExonStart);
eStop = Integer.parseInt(ExonStop);

boolean inExon;
if(eStart &lt;= eStop){
  inExon = eStart &lt;= dStart &amp;&amp; dStop &lt;= eStop;
} else{
  inExon = eStop &lt;= dStart &amp;&amp; dStop &lt;= eStart;
}
isInExon = Boolean.toString(inExon);</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">DStart</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">DStop</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">ExonStart</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">ExonStop</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">isInExon</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
                <s:iterationstrategy>
                  <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
                    <i:dot>
                      <i:iterator name="ExonStop" />
                      <i:iterator name="ExonStart" />
                    </i:dot>
                    <i:dot>
                      <i:iterator name="DStop" />
                      <i:iterator name="DStart" />
                    </i:dot>
                  </i:cross>
                </s:iterationstrategy>
              </s:processor>
              <s:link source="dEnd" sink="checkIsInExon:DStop" />
              <s:link source="dStart" sink="checkIsInExon:DStart" />
              <s:link source="exonEnd" sink="checkIsInExon:ExonStop" />
              <s:link source="exonStart" sink="checkIsInExon:ExonStart" />
              <s:link source="checkIsInExon:isInExon" sink="Fail_if_false:test" />
              <s:link source="checkIsInExon:isInExon" sink="Fail_if_true:test" />
              <s:link source="geneId" sink="Create_BioMart_Record:geneId" />
              <s:link source="transcriptEnd" sink="Create_BioMart_Record:transcriptEnd" />
              <s:link source="transcriptId" sink="Create_BioMart_Record:transcriptId" />
              <s:link source="transcriptStart" sink="Create_BioMart_Record:transcriptStart" />
              <s:link source="Create_BioMart_Record:record" sink="BioMartRecord" />
              <s:link source="EmptyList:list" sink="BioMartRecord" />
              <s:source name="geneId" />
              <s:source name="transcriptId" />
              <s:source name="transcriptStart" />
              <s:source name="transcriptEnd" />
              <s:source name="exonStart" />
              <s:source name="exonEnd" />
              <s:source name="dStart" />
              <s:source name="dEnd" />
              <s:sink name="BioMartRecord" />
              <s:coordination name="Create_BioMart_Record_BLOCKON_Fail_if_false">
                <s:condition>
                  <s:state>Completed</s:state>
                  <s:target>Fail_if_false</s:target>
                </s:condition>
                <s:action>
                  <s:target>Create_BioMart_Record</s:target>
                  <s:statechange>
                    <s:from>Scheduled</s:from>
                    <s:to>Running</s:to>
                  </s:statechange>
                </s:action>
              </s:coordination>
              <s:coordination name="EmptyList_BLOCKON_Fail_if_true">
                <s:condition>
                  <s:state>Completed</s:state>
                  <s:target>Fail_if_true</s:target>
                </s:condition>
                <s:action>
                  <s:target>EmptyList</s:target>
                  <s:statechange>
                    <s:from>Scheduled</s:from>
                    <s:to>Running</s:to>
                  </s:statechange>
                </s:action>
              </s:coordination>
            </s:scufl>
          </s:workflow>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:dot>
                <i:iterator name="exonEnd" />
                <i:iterator name="exonStart" />
                <i:iterator name="transcriptEnd" />
                <i:iterator name="transcriptStart" />
                <i:iterator name="transcriptId" />
                <i:iterator name="geneId" />
              </i:dot>
              <i:dot>
                <i:iterator name="dEnd" />
                <i:iterator name="dStart" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="getExonRegions">
          <s:description>Danio rerio genes (ZFISH7)</s:description>
          <s:defaults>
            <s:default name="drerio_gene_ensembl.biotype_filter">protein_coding</s:default>
          </s:defaults>
          <s:biomart>
            <biomart:MartQuery xmlns:biomart="http://org.embl.ebi.escience/xscufl-biomart/0.1alpha">
              <biomart:MartService location="http://www.biomart.org/biomart/martservice" />
              <biomart:MartDataset displayName="Danio rerio genes (ZFISH7)" name="drerio_gene_ensembl" type="TableSet" initialBatchSize="200" maximumBatchSize="50000" visible="false" interface="default" modified="2008-09-23 16:42:08">
                <biomart:MartURLLocation database="ensembl_mart_51" default="1" displayName="ENSEMBL 51 GENES (SANGER UK)" host="www.biomart.org" includeDatasets="" martUser="" name="ensembl" path="/biomart/martservice" port="80" serverVirtualSchema="default" virtualSchema="default" visible="1" redirect="0" />
              </biomart:MartDataset>
              <biomart:Query virtualSchemaName="default" count="0" uniqueRows="0" softwareVersion="0.7" requestId="taverna">
                <biomart:Dataset name="drerio_gene_ensembl">
                  <biomart:Attribute name="exon_chrom_end" />
                  <biomart:Attribute name="exon_chrom_start" />
                  <biomart:Attribute name="ensembl_transcript_id" />
                  <biomart:Attribute name="ensembl_gene_id" />
                  <biomart:Attribute name="transcript_start" />
                  <biomart:Attribute name="transcript_end" />
                  <biomart:Filter name="chromosomal_region" value="1:100:10000000:1" />
                  <biomart:Filter name="biotype" value="protein_coding" />
                </biomart:Dataset>
              </biomart:Query>
            </biomart:MartQuery>
          </s:biomart>
        </s:processor>
        <s:link source="BioMartReport_Filename" sink="Append_To_BioMartReport:Filename" />
        <s:link source="Add_OligoID_BlastIndex_Prefix:FullRecord" sink="Append_To_BioMartReport:Content" />
        <s:link source="BlastHitsFinished_FileName" sink="Append_To_BlastHitsFinished_File:Filename" />
        <s:link source="CreateBioMartRecord_Iteration:BioMartRecord" sink="Flatten_list:inputlist" />
        <s:link source="Flatten_list:outputlist" sink="Add_OligoID_BlastIndex_Prefix:BioMartRecord" />
        <s:link source="Split_Blast_Record:blastIndex" sink="Add_OligoID_BlastIndex_Prefix:BlastIndex" />
        <s:link source="Split_Blast_Record:blastIndex" sink="Append_To_BlastHitsFinished_File:Content" />
        <s:link source="Split_Blast_Record:chromosomeRegion" sink="getExonRegions:drerio_gene_ensembl.chromosomal_region_filter" />
        <s:link source="Split_Blast_Record:dstop" sink="CreateBioMartRecord_Iteration:dEnd" />
        <s:link source="Split_Blast_Record:oligoId" sink="Add_OligoID_BlastIndex_Prefix:OligoID" />
        <s:link source="blastRecord" sink="Split_Blast_Record:blastRecord" />
        <s:link source="Split_Blast_Record:dstart" sink="CreateBioMartRecord_Iteration:dStart" />
        <s:link source="getExonRegions:drerio_gene_ensembl.ensembl_gene_id" sink="CreateBioMartRecord_Iteration:geneId" />
        <s:link source="getExonRegions:drerio_gene_ensembl.ensembl_transcript_id" sink="CreateBioMartRecord_Iteration:transcriptId" />
        <s:link source="getExonRegions:drerio_gene_ensembl.exon_chrom_end" sink="CreateBioMartRecord_Iteration:exonEnd" />
        <s:link source="getExonRegions:drerio_gene_ensembl.exon_chrom_start" sink="CreateBioMartRecord_Iteration:exonStart" />
        <s:link source="getExonRegions:drerio_gene_ensembl.transcript_end" sink="CreateBioMartRecord_Iteration:transcriptEnd" />
        <s:link source="getExonRegions:drerio_gene_ensembl.transcript_start" sink="CreateBioMartRecord_Iteration:transcriptStart" />
        <s:source name="blastRecord" />
        <s:source name="BioMartReport_Filename" />
        <s:source name="BlastHitsFinished_FileName" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="BlatOrBlast" workers="2">
    <s:description>This workflow combines the blat and blast workflows. It takes as input a database name (Danio_rerio_Genome for Zebra Fish for example) and and a set of Fasta sequences. It first tries to perform a blat (at www.bioinformatics.nl). When this service returns nothing, a blast is done (also at www.bioinformatics.nl). The resulting reports are combined.</s:description>
    <s:workflow maxretries="10" retrydelay="500" critical="true">
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:8c4d9af5-596a-4a31-9c3b-cf79a0693db9" author="" title="BlatBlastCombi" />
        <s:processor name="Fail_if_false">
          <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfFalse</s:local>
        </s:processor>
        <s:processor name="isEmpty">
          <s:beanshell>
            <s:scriptvalue>isEmpty = new Boolean(string.length() == 0).toString();</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">string</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">isEmpty</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Fail_if_true">
          <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
        </s:processor>
        <s:processor name="Filter_Sequences_Not_Found">
          <s:beanshell>
            <s:scriptvalue>// create reader for sequence list
BufferedReader reader = new BufferedReader(new StringReader(Sequences));

// filter sequences
SequencesNotFound = new ArrayList();
String line;

while((line = reader.readLine()) != null){  
  if(line.startsWith("&gt;")){
    String sequenceId = line.substring(1).trim();

    Iterator reportIterator = Report.iterator();

    boolean found = false;
    while(!found &amp;&amp; reportIterator.hasNext()){
      if(reportIterator.next().startsWith(sequenceId)){ 
        found = true;
      }
    }

    if(!found){
      SequencesNotFound.add(sequenceId);
    }
  }
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">Report</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">Sequences</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="l('text/plain')">SequencesNotFound</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Filter_Sequences_For_Blast">
          <s:beanshell>
            <s:scriptvalue>// create reader for sequence list
BufferedReader reader = new BufferedReader(new StringReader(sequences));
StringBuffer blastSequences = new StringBuffer();

// filter sequences
String line;
while((line = reader.readLine()) != null){  
  if(line.startsWith("&gt;")){
    String sequenceId = line.substring(1).trim();

    Iterator reportIterator = blatResult.iterator();
    boolean found = false;
    while(!found &amp;&amp; reportIterator.hasNext()){
      if(reportIterator.next().startsWith(sequenceId)){
        found = true;
      }
    }

    // if sequenceId is not in blat report, than it should be blasted
    if(!found){
      blastSequences.append(line).append("\n").append(reader.readLine()).append("\n");
    } 

  }
}

sequencesForBlast = blastSequences.toString();</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">sequences</s:beanshellinput>
              <s:beanshellinput s:syntactictype="l('text/plain')">blatResult</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">sequencesForBlast</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Append_To_BlastReport" workers="10">
          <s:description>Processor to add content to a (existing)  file. The content is added to the end of the file.

The inputs:
Filename: the file name of a file, if the file does not exists, a new file is added
Content: the string to append
NewLine [default = true]: if true, a newline is added to the end of the line (useful if you want to add a record each time)</s:description>
          <s:beanshell>
            <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, true));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist />
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Append_To_OligosNotFound" workers="10">
          <s:description>Processor to add content to a (existing)  file. The content is added to the end of the file.

The inputs:
Filename: the file name of a file, if the file does not exists, a new file is added
Content: the string to append
NewLine [default = true]: if true, a newline is added to the end of the line (useful if you want to add a record each time)</s:description>
          <s:beanshell>
            <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.appendFileSemaphore == void){
  bsh.shared.appendFileSemaphore = new Semaphore(1);
}

PrintStream stream;
try{
  bsh.shared.appendFileSemaphore.acquire();

  stream = new PrintStream(new FileOutputStream(Filename, true));
  if(NewLine == void){
    NewLine = "true";
  }
  if(Boolean.parseBoolean(NewLine)){
    stream.println(Content);
  } else{
    stream.print(Content);
  }
} finally{
  if(stream != void){
    stream.close();
  }
  bsh.shared.appendFileSemaphore.release();
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">Filename</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">Content</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">NewLine</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist />
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Join_Blat_Blast_Results">
          <s:beanshell>
            <s:scriptvalue>outputList = new ArrayList();
outputList.addAll(list1);
outputList.addAll(list2);</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">list1</s:beanshellinput>
              <s:beanshellinput s:syntactictype="l('text/plain')">list2</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="l('text/plain')">outputList</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="EmptyList">
          <s:beanshell>
            <s:scriptvalue>list = new ArrayList();</s:scriptvalue>
            <s:beanshellinputlist />
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="l('text/plain')">list</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Add_Indices_To_BlastReport">
          <s:beanshell>
            <s:scriptvalue>import java.util.concurrent.Semaphore;

if(bsh.shared.blastReportIndex == void){
  bsh.shared.blastReportIndex = 1;
}

if(bsh.shared.addIndexSemaphore == void){
  bsh.shared.addIndexSemaphore = new Semaphore(1);
}

try{
  bsh.shared.addIndexSemaphore.acquire();
  record_with_index = record + "\t" + bsh.shared.blastReportIndex++;
} finally{
  bsh.shared.addIndexSemaphore.release();
}</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">record</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">record_with_index</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Blast">
          <s:description>This workflow invokes the blast service provided at www.bioinformatics.nl, written by Pieter Neerincx. The workflow takes as input a database name (Danio_rerio_Genome for Zebra Fish for example) and a set of sequences in fasta format.

The blast service is invoked (using polling) and the result is a tab separated blast report.</s:description>
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:8eb05694-c30b-4baf-889c-961922578e8c" author="Ingo Wassink, Han Rauwerda, Pieter Neerincx" title="Blast">This workflow invokes the blast service provided at www.bioinformatics.nl, written by Pieter Neerincx. The workflow takes as input a database name (Danio_rerio_Genome for Zebra Fish for example) and a set of sequences in fasta format.

The blast service is invoked (using polling) and the result is a tab separated blast report.</s:workflowdescription>
              <s:processor name="DownloadURLWithBasicAuth">
                <s:description>This Beanshell downloads a file to disk. The standard download local Java widgets don't handle URLs with HTTP(S) Basic Authentication, but this Beanshell can. When a webserver uses BasicAuth, a login and password can be coded as part of the URL using the following syntax: http(s)://login:password@www.some.website/my/great/tool/result.xml. This beanshel extracts the login and password from the URL and supplies them automatically to the webserver. This prevents Taverna from showing popup dialogs requesting the login and password from the user as this will be problematic for large workflows.

Please note that the path where the downloaded file will be stored must be an absolute path to a folder ended with a slash. (Slash backward on Windows or a slash forward on Linux/Unix/Mac OS X.) The filename for the result is automatically extracted from the URL.</s:description>
                <s:beanshell>
                  <s:scriptvalue>//
// Import modules;
//
import java.io.*;
import java.net.*;
import java.util.regex.*;

// Connect to URL.
URL oURL = new URL(theURL);
URLConnection oURLConnection = oURL.openConnection();

// Check if we are are dealing with a site 
// that uses basic http(s) authentication.
oPattern = Pattern.compile("(\\w+://)??([^:]+):([^:@]+)@.*");
oMatcher = oPattern.matcher(oURL.toString());
vHit = oMatcher.matches();
if (vHit) {
	//String vProtocol = oMatcher.group(1);
	String vUser = oMatcher.group(2);
	String vPass = oMatcher.group(3);
	String vAuth = vUser + ":" + vPass;
	String vEncodedUserPassword = new sun.misc.BASE64Encoder().encode(vAuth.getBytes());
	oURLConnection.setRequestProperty ("Authorization", "Basic " + vEncodedUserPassword);	
}

InputStream inputStream = oURLConnection.getInputStream();
BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

blastResults = new ArrayList();
String line;
while((line = reader.readLine()) != null){
  blastResults.add(line);
}

reader.close();</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">theURL</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">blastResults</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="Flatten_urls">
                <s:local>org.embl.ebi.escience.scuflworkers.java.StringListMerge</s:local>
              </s:processor>
              <s:processor name="Parse_Moby_Data_URL">
                <s:description>Processor to parse the datatype URL</s:description>
                <s:biomobyparser>
                  <s:endpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:endpoint>
                  <s:datatype>URL</s:datatype>
                  <s:articleName>result</s:articleName>
                  <s:description>Processor to parse the datatype URL</s:description>
                </s:biomobyparser>
              </s:processor>
              <s:processor name="BlastJob">
                <s:description>A BLAST job.</s:description>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>BlastJob</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="Poll_Job">
                <s:workflow maxretries="10000" retrydelay="500">
                  <s:scufl version="0.2" log="0">
                    <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:a7f029f5-ea3d-4939-8adc-5d388bcd02b3" author="" title="Poll_Job" />
                    <s:processor name="Get_Job_ID">
                      <s:defaults>
                        <s:default name="xpath">//moby:Simple/*/@id</s:default>
                      </s:defaults>
                      <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
                    </s:processor>
                    <s:processor name="Fail_if_true">
                      <s:local critical="true">org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
                    </s:processor>
                    <s:processor name="Correct_Moby_Object">
                      <s:beanshell>
                        <s:scriptvalue>outputXML = inputXML.replace("&lt;Object articleName=\"\"", "&lt;Object articleName=\"job_id\"");</s:scriptvalue>
                        <s:beanshellinputlist>
                          <s:beanshellinput s:syntactictype="'text/plain'">inputXML</s:beanshellinput>
                        </s:beanshellinputlist>
                        <s:beanshelloutputlist>
                          <s:beanshelloutput s:syntactictype="'text/plain'">outputXML</s:beanshelloutput>
                        </s:beanshelloutputlist>
                        <s:dependencies s:classloader="iteration" />
                      </s:beanshell>
                    </s:processor>
                    <s:processor name="isRunning">
                      <s:beanshell>
                        <s:scriptvalue>// if status is "r", than is running, "f" is finished
isRunning = new Boolean(status.equals("r")).toString();</s:scriptvalue>
                        <s:beanshellinputlist>
                          <s:beanshellinput s:syntactictype="'text/plain'">status</s:beanshellinput>
                        </s:beanshellinputlist>
                        <s:beanshelloutputlist>
                          <s:beanshelloutput s:syntactictype="'text/plain'">isRunning</s:beanshelloutput>
                        </s:beanshelloutputlist>
                        <s:dependencies s:classloader="iteration" />
                      </s:beanshell>
                    </s:processor>
                    <s:processor name="MergeID">
                      <s:defaults>
                        <s:default name="seperator" />
                      </s:defaults>
                      <s:local>org.embl.ebi.escience.scuflworkers.java.StringListMerge</s:local>
                    </s:processor>
                    <s:processor name="Parse_Moby_Data_Object">
                      <s:description>Processor to parse the datatype Object</s:description>
                      <s:biomobyparser>
                        <s:endpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:endpoint>
                        <s:datatype>Object</s:datatype>
                        <s:articleName>status</s:articleName>
                        <s:description>Processor to parse the datatype Object</s:description>
                      </s:biomobyparser>
                    </s:processor>
                    <s:processor name="MobyBlast_poll">
                      <s:description>Submit the result of the MobyBlast_submit service and obtain status info for the job.</s:description>
                      <s:biomobywsdl>
                        <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                        <s:serviceName>MobyBlast_poll</s:serviceName>
                        <s:authorityName>www.bioinformatics.nl</s:authorityName>
                      </s:biomobywsdl>
                    </s:processor>
                    <s:processor name="Object">
                      <s:description>an object</s:description>
                      <s:defaults>
                        <s:default name="namespace">www.bioinformatics.nl</s:default>
                        <s:default name="article name">job_id</s:default>
                      </s:defaults>
                      <s:biomobyobject>
                        <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                        <s:serviceName>Object</s:serviceName>
                        <s:authorityName />
                      </s:biomobyobject>
                    </s:processor>
                    <s:link source="BlastJob" sink="Get_Job_ID:xml-text" />
                    <s:link source="Correct_Moby_Object:outputXML" sink="MobyBlast_poll:Object(job_id)" />
                    <s:link source="Get_Job_ID:nodelist" sink="MergeID:stringlist" />
                    <s:link source="MergeID:concatenated" sink="Object:id" />
                    <s:link source="MobyBlast_poll:Object(status)" sink="Parse_Moby_Data_Object:mobyData('Object')" />
                    <s:link source="Object:mobyData" sink="Correct_Moby_Object:inputXML" />
                    <s:link source="Parse_Moby_Data_Object:id" sink="isRunning:status" />
                    <s:link source="isRunning:isRunning" sink="Fail_if_true:test" />
                    <s:source name="BlastJob" />
                  </s:scufl>
                </s:workflow>
              </s:processor>
              <s:processor name="String">
                <s:description>a string</s:description>
                <s:defaults>
                  <s:default name="id">fasta</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>String</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="User">
                <s:description>A generic user object.</s:description>
                <s:defaults>
                  <s:default name="namespace">www.bioinformatics.nl</s:default>
                  <s:default name="id">client</s:default>
                  <s:default name="article name">user</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>User</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="MobyBlast_submit">
                <s:description>Submit a BLAST Job and retrieve a Job ID. Use this Job ID with the MobyBlast_poll service from the same service provider to check the status of your job.Use this Job ID with the MobyBlast_retrieve service from the same service provider to fetch the results.</s:description>
                <s:biomobywsdl maxretries="30" retrydelay="500">
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>MobyBlast_submit</s:serviceName>
                  <s:authorityName>www.bioinformatics.nl</s:authorityName>
                  <s:Parameter s:name="t">0</s:Parameter>
                  <s:Parameter s:name="g">T</s:Parameter>
                  <s:Parameter s:name="s">F</s:Parameter>
                  <s:Parameter s:name="J">T</s:Parameter>
                  <s:Parameter s:name="W">0</s:Parameter>
                  <s:Parameter s:name="v">500</s:Parameter>
                  <s:Parameter s:name="e">0.00015</s:Parameter>
                  <s:Parameter s:name="B">0</s:Parameter>
                  <s:Parameter s:name="D">1</s:Parameter>
                  <s:Parameter s:name="q">-3</s:Parameter>
                  <s:Parameter s:name="b">250</s:Parameter>
                  <s:Parameter s:name="I">F</s:Parameter>
                  <s:Parameter s:name="G">0</s:Parameter>
                  <s:Parameter s:name="z">0</s:Parameter>
                  <s:Parameter s:name="U">F</s:Parameter>
                  <s:Parameter s:name="F">T</s:Parameter>
                  <s:Parameter s:name="w">0</s:Parameter>
                  <s:Parameter s:name="r">1</s:Parameter>
                  <s:Parameter s:name="Q">1</s:Parameter>
                  <s:Parameter s:name="M">BLOSUM62</s:Parameter>
                  <s:Parameter s:name="C">0</s:Parameter>
                  <s:Parameter s:name="f">0</s:Parameter>
                  <s:Parameter s:name="L" />
                  <s:Parameter s:name="A">0</s:Parameter>
                  <s:Parameter s:name="n">F</s:Parameter>
                  <s:Parameter s:name="X">0</s:Parameter>
                  <s:Parameter s:name="P">0</s:Parameter>
                  <s:Parameter s:name="m">8</s:Parameter>
                  <s:Parameter s:name="y">0</s:Parameter>
                  <s:Parameter s:name="Z">0</s:Parameter>
                  <s:Parameter s:name="Y">0</s:Parameter>
                  <s:Parameter s:name="E">0</s:Parameter>
                  <s:Parameter s:name="K" />
                  <s:Parameter s:name="S">3</s:Parameter>
                </s:biomobywsdl>
              </s:processor>
              <s:processor name="Program">
                <s:description>A generic program object.</s:description>
                <s:defaults>
                  <s:default name="namespace">blast</s:default>
                  <s:default name="id">blastn</s:default>
                  <s:default name="article name">program</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>Program</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="Email">
                <s:description>An e-mail address object.</s:description>
                <s:defaults>
                  <s:default name="namespace">www.bioinformatics.nl</s:default>
                  <s:default name="id">some.user@domain.nl</s:default>
                  <s:default name="article name">email</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>Email</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="DataBase">
                <s:description>A database object.</s:description>
                <s:defaults>
                  <s:default name="namespace">blast</s:default>
                  <s:default name="article name">database</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>DataBase</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="FASTA">
                <s:description>FASTA formatted sequence</s:description>
                <s:defaults>
                  <s:default name="id">1</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>FASTA</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="Password">
                <s:description>A generic password object.</s:description>
                <s:defaults>
                  <s:default name="namespace">www.bioinformatics.nl</s:default>
                  <s:default name="id">testing</s:default>
                  <s:default name="article name">password</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>Password</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:link source="BlastJob:mobyData" sink="MobyBlast_submit:BlastJob(input)" />
              <s:link source="DataBase:mobyData" sink="BlastJob:DataBase(database)" />
              <s:link source="DataBaseName" sink="DataBase:id" />
              <s:link source="Email:mobyData" sink="User:Email(email)" />
              <s:link source="FASTA:mobyData" sink="BlastJob:FASTA(fasta)" />
              <s:link source="MobyBlast_submit:BlastJob(output)" sink="Poll_Job:BlastJob" />
              <s:link source="MobyBlast_submit:URL(result)" sink="Parse_Moby_Data_URL:mobyData('URL')" />
              <s:link source="Parse_Moby_Data_URL:id" sink="Flatten_urls:stringlist" />
              <s:link source="Password:mobyData" sink="User:Password(password)" />
              <s:link source="Program:mobyData" sink="BlastJob:Program(program)" />
              <s:link source="Sequences" sink="String:value" />
              <s:link source="Flatten_urls:concatenated" sink="DownloadURLWithBasicAuth:theURL" />
              <s:link source="String:mobyData" sink="FASTA:String(content)" />
              <s:link source="User:mobyData" sink="MobyBlast_submit:User(user)" />
              <s:link source="DownloadURLWithBasicAuth:blastResults" sink="BlastResults" />
              <s:source name="Sequences">
                <s:metadata>
                  <s:description>Sequences in fasta format</s:description>
                </s:metadata>
              </s:source>
              <s:source name="DataBaseName">
                <s:metadata>
                  <s:description>Database name (Danio_rerio_Genome for Zebra Fish)</s:description>
                </s:metadata>
              </s:source>
              <s:sink name="BlastResults" />
              <s:coordination name="DownloadURLWithBasicAuth_BLOCKON_Poll_Job">
                <s:condition>
                  <s:state>Completed</s:state>
                  <s:target>Poll_Job</s:target>
                </s:condition>
                <s:action>
                  <s:target>DownloadURLWithBasicAuth</s:target>
                  <s:statechange>
                    <s:from>Scheduled</s:from>
                    <s:to>Running</s:to>
                  </s:statechange>
                </s:action>
              </s:coordination>
            </s:scufl>
          </s:workflow>
        </s:processor>
        <s:processor name="Blat">
          <s:description>The blat workflow invokes the blat services provided at www.bioinformatics.nl (author Pieter Neerincx).

As input, it takes a database name (for example, Danio_rerio_Genome for Zebra Fish) and one or more sequences in Fasta format. The output will be a tab separated output of the blat. An eValue string constant is added to filter on the e-Value.

Note, the e-Value is not exactly the same as the blast e-Value.</s:description>
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:29ce4255-9c51-46f7-a517-5b9bcc275069" author="Ingo Wassink, Han Rauwerda, Pieter Neerincx" title="Blat">The blat workflow invokes the blat services provided at www.bioinformatics.nl (author Pieter Neerincx).

As input, it takes a database name (for example, Danio_rerio_Genome for Zebra Fish) and one or more sequences in Fasta format. The output will be a tab separated output of the blat. An eValue string constant is added to filter on the e-Value.

Note, the e-Value is not exactly the same as the blast e-Value.</s:workflowdescription>
              <s:processor name="Download_Report_and_Filter">
                <s:description>This Beanshell downloads a file to disk. The standard download local Java widgets don't handle URLs with HTTP(S) Basic Authentication, but this Beanshell can. When a webserver uses BasicAuth, a login and password can be coded as part of the URL using the following syntax: http(s)://login:password@www.some.website/my/great/tool/result.xml. This beanshel extracts the login and password from the URL and supplies them automatically to the webserver. This prevents Taverna from showing popup dialogs requesting the login and password from the user as this will be problematic for large workflows.

Please note that the path where the downloaded file will be stored must be an absolute path to a folder ended with a slash. (Slash backward on Windows or a slash forward on Linux/Unix/Mac OS X.) The filename for the result is automatically extracted from the URL.</s:description>
                <s:beanshell>
                  <s:scriptvalue>//
// Import modules;
//
import java.io.*;
import java.net.*;
import java.util.regex.*;


// Connect to URL.
URL oURL = new URL(URL);
URLConnection oURLConnection = oURL.openConnection();

// Check if we are are dealing with a site 
// that uses basic http(s) authentication.
oPattern = Pattern.compile("(\\w+://)??([^:]+):([^:@]+)@.*");
oMatcher = oPattern.matcher(URL);
vHit = oMatcher.matches();
if (vHit) {
	//String vProtocol = oMatcher.group(1);
	String vUser = oMatcher.group(2);
	String vPass = oMatcher.group(3);
	String vAuth = vUser + ":" + vPass;
	String vEncodedUserPassword = new sun.misc.BASE64Encoder().encode(vAuth.getBytes());
	oURLConnection.setRequestProperty ("Authorization", "Basic " + vEncodedUserPassword);	
}

// get input stream
InputStream inputStream = oURLConnection.getInputStream();


// download all results and filter
BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
List blatResults = new ArrayList();
double ev = Double.parseDouble(eValue);

String line;
while((line = reader.readLine()) != null){
  String[] values = line.split("\t");
  double currentEValue = Double.parseDouble(values[values.length-2]);

  if(currentEValue &lt; ev){
    blatResults.add(line);
  }
}
reader.close();</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">URL</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">eValue</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">blatResults</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="eValue" boring="true">
                <s:stringconstant>0.00015</s:stringconstant>
              </s:processor>
              <s:processor name="Flatten_urls">
                <s:defaults>
                  <s:default name="seperator" />
                </s:defaults>
                <s:local>org.embl.ebi.escience.scuflworkers.java.StringListMerge</s:local>
              </s:processor>
              <s:processor name="Password">
                <s:description>A generic password object.</s:description>
                <s:defaults>
                  <s:default name="namespace">www.bioinformatics.nl</s:default>
                  <s:default name="id">testing</s:default>
                  <s:default name="article name">password</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>Password</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="BlatJob">
                <s:description>A BLAT job.</s:description>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>BlatJob</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="Parse_Moby_Data_URL">
                <s:description>Processor to parse the datatype URL</s:description>
                <s:biomobyparser>
                  <s:endpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:endpoint>
                  <s:datatype>URL</s:datatype>
                  <s:articleName>result</s:articleName>
                  <s:description>Processor to parse the datatype URL</s:description>
                </s:biomobyparser>
              </s:processor>
              <s:processor name="Email">
                <s:description>An e-mail address object.</s:description>
                <s:defaults>
                  <s:default name="namespace">www.bioinformatics.nl</s:default>
                  <s:default name="id">some.user@domain.nl</s:default>
                  <s:default name="article name">email</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>Email</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="MobyBlat">
                <s:description>BioMOBY web service wrapper for the command line query tool 'BLAT'.</s:description>
                <s:biomobywsdl maxretries="30" retrydelay="500">
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>MobyBlat</s:serviceName>
                  <s:authorityName>www.bioinformatics.nl</s:authorityName>
                  <s:Parameter s:name="out">blast8</s:Parameter>
                  <s:Parameter s:name="q">dna</s:Parameter>
                  <s:Parameter s:name="minScore">0</s:Parameter>
                  <s:Parameter s:name="minIdentity">0</s:Parameter>
                  <s:Parameter s:name="maxIntron">1000000</s:Parameter>
                </s:biomobywsdl>
              </s:processor>
              <s:processor name="User">
                <s:description>A generic user object.</s:description>
                <s:defaults>
                  <s:default name="namespace">www.bioinformatics.nl</s:default>
                  <s:default name="id">client</s:default>
                  <s:default name="article name">user</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>User</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="DataBase">
                <s:description>A database object.</s:description>
                <s:defaults>
                  <s:default name="namespace">blat</s:default>
                  <s:default name="article name">dataBase</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>DataBase</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="String">
                <s:description>a string</s:description>
                <s:defaults>
                  <s:default name="article name">fasta</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>String</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:processor name="FASTA">
                <s:description>FASTA formatted sequence</s:description>
                <s:defaults>
                  <s:default name="id">1</s:default>
                </s:defaults>
                <s:biomobyobject>
                  <s:mobyEndpoint>http://moby.ucalgary.ca/moby/MOBY-Central.pl</s:mobyEndpoint>
                  <s:serviceName>FASTA</s:serviceName>
                  <s:authorityName />
                </s:biomobyobject>
              </s:processor>
              <s:link source="BlatJob:mobyData" sink="MobyBlat:BlatJob(input)" />
              <s:link source="DataBase" sink="DataBase:id" />
              <s:link source="DataBase:mobyData" sink="BlatJob:DataBase(database)" />
              <s:link source="Email:mobyData" sink="User:Email(email)" />
              <s:link source="FASTA:mobyData" sink="BlatJob:FASTA(fasta)" />
              <s:link source="MobyBlat:URL(result)" sink="Parse_Moby_Data_URL:mobyData('URL')" />
              <s:link source="Sequences" sink="String:value" />
              <s:link source="Flatten_urls:concatenated" sink="Download_Report_and_Filter:URL" />
              <s:link source="Parse_Moby_Data_URL:id" sink="Flatten_urls:stringlist" />
              <s:link source="Password:mobyData" sink="User:Password(password)" />
              <s:link source="String:mobyData" sink="FASTA:String(content)" />
              <s:link source="User:mobyData" sink="MobyBlat:User(user)" />
              <s:link source="eValue:value" sink="Download_Report_and_Filter:eValue" />
              <s:link source="Download_Report_and_Filter:blatResults" sink="blatResults" />
              <s:source name="DataBase">
                <s:metadata>
                  <s:description>Database name (Danio_rerio_Genome for Zebra Fish)</s:description>
                </s:metadata>
              </s:source>
              <s:source name="Sequences">
                <s:metadata>
                  <s:description>Sequences in fasta format</s:description>
                </s:metadata>
              </s:source>
              <s:sink name="blatResults" />
            </s:scufl>
          </s:workflow>
        </s:processor>
        <s:link source="BlastReport_Filename" sink="Append_To_BlastReport:Filename" />
        <s:link source="DataBaseName" sink="Blast:DataBaseName" />
        <s:link source="DataBaseName" sink="Blat:DataBase" />
        <s:link source="Sequences" sink="Blat:Sequences" />
        <s:link source="Sequences" sink="Filter_Sequences_For_Blast:sequences" />
        <s:link source="Blast:BlastResults" sink="Join_Blat_Blast_Results:list2" />
        <s:link source="Blat:blatResults" sink="Filter_Sequences_For_Blast:blatResult" />
        <s:link source="Blat:blatResults" sink="Join_Blat_Blast_Results:list1" />
        <s:link source="EmptyList:list" sink="Join_Blat_Blast_Results:list2" />
        <s:link source="Filter_Sequences_For_Blast:sequencesForBlast" sink="Blast:Sequences" />
        <s:link source="Filter_Sequences_For_Blast:sequencesForBlast" sink="isEmpty:string" />
        <s:link source="Filter_Sequences_Not_Found:SequencesNotFound" sink="Append_To_OligosNotFound:Content" />
        <s:link source="Join_Blat_Blast_Results:outputList" sink="Filter_Sequences_Not_Found:Report" />
        <s:link source="OligosNotFound_Filename" sink="Append_To_OligosNotFound:Filename" />
        <s:link source="Sequences" sink="Filter_Sequences_Not_Found:Sequences" />
        <s:link source="Add_Indices_To_BlastReport:record_with_index" sink="Append_To_BlastReport:Content" />
        <s:link source="Join_Blat_Blast_Results:outputList" sink="Add_Indices_To_BlastReport:record" />
        <s:link source="isEmpty:isEmpty" sink="Fail_if_false:test" />
        <s:link source="isEmpty:isEmpty" sink="Fail_if_true:test" />
        <s:source name="DataBaseName">
          <s:metadata>
            <s:description>The name of the database (Danio_rerio_Genome for Zebra Fish)</s:description>
          </s:metadata>
        </s:source>
        <s:source name="Sequences">
          <s:metadata>
            <s:description>Fasta sequences</s:description>
          </s:metadata>
        </s:source>
        <s:source name="OligosNotFound_Filename" />
        <s:source name="BlastReport_Filename" />
        <s:coordination name="Blast_BLOCKON_Fail_if_true">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>Fail_if_true</s:target>
          </s:condition>
          <s:action>
            <s:target>Blast</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
        <s:coordination name="EmptyList_BLOCKON_Fail_if_false">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>Fail_if_false</s:target>
          </s:condition>
          <s:action>
            <s:target>EmptyList</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:link source="DataBaseName" sink="BlatOrBlast:DataBaseName" />
  <s:link source="BioMartReport_Filename:value" sink="Create_Header_BioMartReport:Filename" />
  <s:link source="BioMartReport_Filename:value" sink="DoBioMart:BioMartReport_Filename" />
  <s:link source="BioMartReport_Filename:value" sink="Read_BioMartReport:fileurl" />
  <s:link source="BlastReport_Filename:value" sink="BlatOrBlast:BlastReport_Filename" />
  <s:link source="BlastReport_Filename:value" sink="Create_Header_BlastReport:Filename" />
  <s:link source="BlastReport_Filename:value" sink="Read_BlastReport:fileurl" />
  <s:link source="Chunk_Size:value" sink="Create_Sequence_Chunks:chunkSize" />
  <s:link source="Create_Sequence_Chunks:chunks" sink="BlatOrBlast:Sequences" />
  <s:link source="OligosNotFound_Filename:value" sink="BlatOrBlast:OligosNotFound_Filename" />
  <s:link source="OligosNotFound_Filename:value" sink="Read_OligosNotFound:fileurl" />
  <s:link source="OligosNotFound_Filename:value" sink="Touch_OligosNotFound_File:Filename" />
  <s:link source="Read_BioMartReport:filecontents" sink="GeneratePlots:biomartfile" />
  <s:link source="Read_BlastReport:filecontents" sink="GeneratePlots:blastresultfile" />
  <s:link source="Read_BlastReport:filecontents" sink="Split_Blast_Report:BlastReport" />
  <s:link source="Read_OligosNotFound:filecontents" sink="GeneratePlots:oligosNotFound" />
  <s:link source="Restart" sink="Create_Header_BioMartReport:Restart" />
  <s:link source="Restart" sink="Create_Header_BlastReport:Restart" />
  <s:link source="Sequences" sink="Filter_Sequences_For_Blast:sequences" />
  <s:link source="BlastHitsFinished_Filename:value" sink="Touch_BlastHitsFinished_File:Filename" />
  <s:link source="BlastReport_Filename:value" sink="Filter_Sequences_For_Blast:filename" />
  <s:link source="Filter_Sequences_For_Blast:sequencesToDo" sink="Split_sequences:sequenceText" />
  <s:link source="Restart" sink="Touch_BlastHitsFinished_File:Restart" />
  <s:link source="BlastHitsFinished_Filename:value" sink="DoBioMart:BlastHitsFinished_FileName" />
  <s:link source="BlastHitsFinished_Filename:value" sink="Split_Blast_Report:filename" />
  <s:link source="GeneratePlots:BarPlot" sink="BarPlot" />
  <s:link source="GeneratePlots:Classes" sink="Classes" />
  <s:link source="GeneratePlots:Report" sink="Report" />
  <s:link source="Read_BioMartReport:filecontents" sink="BioMartReport" />
  <s:link source="Read_BlastReport:filecontents" sink="BlastReport" />
  <s:link source="Read_OligosNotFound:filecontents" sink="SequencesNotFound" />
  <s:link source="Split_Blast_Report:Records" sink="DoBioMart:blastRecord" />
  <s:link source="Split_sequences:sequences" sink="Create_Sequence_Chunks:sequences" />
  <s:source name="DataBaseName">
    <s:metadata>
      <s:description>Database name (for example Danio_rerio_Genome)</s:description>
    </s:metadata>
  </s:source>
  <s:source name="Sequences">
    <s:metadata>
      <s:description>Sequences in fasta format, for example

&gt;ENSDART00000061775
TTGTTTCCTCATCAACACAGCAGATCGAATCATTCGAGTTTACGACGGTCGAGAGATCCT
&gt;ENSDART00000100022
TGCTGTTCAGTGGTTATGTTGTTGTTTGAATAAATGTTAAGAGCCAGTGGATGGCACAAA
&gt;OTTDART00000006800
ATCTCTTAGCACTCTGCTGACTCACAACTTCTTCAGAAATGACTTTTTGGATATCATGAA
&gt;OTTDART00000002447
AAGACTGTACGACAAGACAGTGCAAATGGCACCATAGTAAATTCAACCGCTCACCAGGAA
&gt;ENSDART00000047499
CTCTATGACGTATATTGCTATGTGGAGAACATTCATGGGGAGGTTTTTCATGGCTCAACC
&gt;ENSDART00000093312
CAGAGGGTTGCAACCTCTTCATCTATCATCTACCACAAGAGTTTGGTGACAATGAGCTTA
&gt;OTTDART00000002445
AATGTTGCTGGTATCAGTGACCCCTTTCTGCAGGTGCGCATTCTTAGATTGCTAAGGATT
&gt;ENSDART00000093311
CGGGCCTTTCTGGAGAAACGCAAACCTGTGTGGAGCAACACAGACGACTGCATTCACTGA
&gt;ENSDART00000085701
AGAATGACAATGACTGTGGAGCTTTTGTTTTGGAGTACTGTAAGTGCCTGGCCTTCATGA
&gt;OTTDART00000002443
AAACCATCACGCTTTAATTAGTTTCCCCTGTTAACCATTGTCCCACAAGTCTTATGTGGA
&gt;OTTDART00000002442
CTGAAAGGCACTTGAGTTAATCAAATCCGCTTCTATGTAAGTGTTTTGTAAGAGCAGGCT</s:description>
    </s:metadata>
  </s:source>
  <s:source name="Restart">
    <s:metadata>
      <s:description>Whether the workflow should start from scratch. 
If false, the workflow will continue. This is useful if a crash has occured
in Taverna (and it does sometimes when the data set is large)</s:description>
    </s:metadata>
  </s:source>
  <s:sink name="BlastReport">
    <s:metadata>
      <s:description>The blast hits</s:description>
    </s:metadata>
  </s:sink>
  <s:sink name="BioMartReport">
    <s:metadata>
      <s:description>The biomart genes and transcripts</s:description>
    </s:metadata>
  </s:sink>
  <s:sink name="SequencesNotFound">
    <s:metadata>
      <s:description>The sequences not found by blast and blat</s:description>
    </s:metadata>
  </s:sink>
  <s:sink name="BarPlot">
    <s:metadata>
      <s:description>A bar plot of the oligos per class</s:description>
    </s:metadata>
  </s:sink>
  <s:sink name="Classes">
    <s:metadata>
      <s:description>The classes, same as bar plot</s:description>
    </s:metadata>
  </s:sink>
  <s:sink name="Report">
    <s:metadata>
      <s:description>The total R report</s:description>
    </s:metadata>
  </s:sink>
  <s:coordination name="BlatOrBlast_BLOCKON_Create_Header_BlastReport">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Header_BlastReport</s:target>
    </s:condition>
    <s:action>
      <s:target>BlatOrBlast</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Read_BlastReport_BLOCKON_BlatOrBlast">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>BlatOrBlast</s:target>
    </s:condition>
    <s:action>
      <s:target>Read_BlastReport</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Read_OligosNotFound_BLOCKON_BlatOrBlast">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>BlatOrBlast</s:target>
    </s:condition>
    <s:action>
      <s:target>Read_OligosNotFound</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Read_BioMartReport_BLOCKON_DoBioMart">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>DoBioMart</s:target>
    </s:condition>
    <s:action>
      <s:target>Read_BioMartReport</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="DoBioMart_BLOCKON_Create_Header_BioMartReport">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Header_BioMartReport</s:target>
    </s:condition>
    <s:action>
      <s:target>DoBioMart</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Filter_Sequences_For_Blast_BLOCKON_Create_Header_BlastReport">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Header_BlastReport</s:target>
    </s:condition>
    <s:action>
      <s:target>Filter_Sequences_For_Blast</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="BlatOrBlast_BLOCKON_Touch_OligosNotFound_File">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Touch_OligosNotFound_File</s:target>
    </s:condition>
    <s:action>
      <s:target>BlatOrBlast</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Create_Header_BlastReport_BLOCKON_Create_Semaphore">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Semaphore</s:target>
    </s:condition>
    <s:action>
      <s:target>Create_Header_BlastReport</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Touch_OligosNotFound_File_BLOCKON_Create_Semaphore">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Semaphore</s:target>
    </s:condition>
    <s:action>
      <s:target>Touch_OligosNotFound_File</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Create_Header_BioMartReport_BLOCKON_Create_Semaphore">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Semaphore</s:target>
    </s:condition>
    <s:action>
      <s:target>Create_Header_BioMartReport</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="Touch_BlastHitsFinished_File_BLOCKON_Create_Semaphore">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Create_Semaphore</s:target>
    </s:condition>
    <s:action>
      <s:target>Touch_BlastHitsFinished_File</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
</s:scufl>

