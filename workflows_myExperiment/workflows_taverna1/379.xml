<?xml version="1.0" encoding="UTF-8"?>
<s:scufl xmlns:s="http://org.embl.ebi.escience/xscufl/0.1alpha" version="0.2" log="0">
  <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:00d3cce3-2ad3-4c81-af98-a61f6f312cec" author="Marco Roos (workflow) and the AID team (services)" title="BioAID_EnirchBioModelWithProteinsFromText">This workflow extracts proteins and protein relations from Medline. Extracted protein  names (symbols of at least 3 characters) are validated against mouse, rat, and human UniProt symbols, so the results are limited to these species.

This workflow follows the following basic steps:
1. it retrieves documents relevant for the query string
2. it discovers proteins in those documents, considered relevant to the query string (colocation in text mining terms)
3. it extract protein-protein relations (slightly stronger than colocation)

In addition, the results are added to a biological model to support hypthesis formation and  a procedural model to log trails to evidence. The models are based on description logic (RDF/OWL format).

Acknowledgements:
Synonyms and Uniprot services: Martijn Scheumie, BioSemantics Group, University of Rotterdam, The Netherlands (BioRange project)</s:workflowdescription>
  <s:processor name="false" boring="true">
    <s:stringconstant>false</s:stringconstant>
  </s:processor>
  <s:processor name="MedLineTotalDocCount" boring="true">
    <s:stringconstant>17000000</s:stringconstant>
  </s:processor>
  <s:processor name="MinLogLikelhoodScoreDescription" boring="true">
    <s:stringconstant>-log likelihood ratio for finding query q and discovery d together computed by -log((QD_exp / N) / (QD_obs / N)), QD_exp = (Q/D)/N, where Q is the frequency of documents containing query q, D is the frequency of documents containing the discovery d, and QD the frequency of documents containing both q and d; QD_exp is the expected frequency of documents containing q and d assuming independence of q and d (H0). This score is a measure of 'specialness' of finding q and d together.</s:stringconstant>
  </s:processor>
  <s:processor name="true" boring="true">
    <s:stringconstant>true</s:stringconstant>
  </s:processor>
  <s:processor name="Fail">
    <s:defaults>
      <s:default name="test">true</s:default>
    </s:defaults>
    <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
  </s:processor>
  <s:processor name="s06_AddProteinRelationToSemanticModel">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:d58ca285-c662-4a60-a085-e7a58f65f65b" author="" title="AddProteinRelationToSemanticModel" />
        <s:link source="interaction_term" sink="interaction_instance" />
        <s:source name="protein_name1" />
        <s:source name="protein_name2" />
        <s:source name="interaction_term" />
        <s:source name="uniprot_id1" />
        <s:source name="uniprot_id2" />
        <s:source name="doc_instance" />
        <s:sink name="interaction_instance" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="doc_instance" />
        <i:dot>
          <i:iterator name="uniprot_id2" />
          <i:iterator name="uniprot_id1" />
          <i:iterator name="protein_name2" />
          <i:iterator name="protein_name1" />
          <i:iterator name="interaction_term" />
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="negate">
    <s:beanshell>
      <s:scriptvalue>String input = true_or_false;
String output = "true";

if (input.equals("true") || input.equals("True") || input.equals("TRUE") || input.equals("yes") || input.equals("Yes") || input.equals("YES")) {
	output = "false";
} else {
	output = "true";
}

false_or_true = output;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">true_or_false</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/plain'">false_or_true</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="CountProteinsPerDocument">
    <s:beanshell>
      <s:scriptvalue>count = list.size();</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="l('text/xml')">list</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/plain'">count</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="CloneStringToList_NERserviceRunInstance">
    <s:beanshell>
      <s:scriptvalue>import java.util.*;

List newlist = new ArrayList();

for (int i=0; i&lt;((int) Integer.parseInt(copy_number.toString())); i++) {
	newlist.add(input);
}

clones=newlist;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">copy_number</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="l('text/plain')">clones</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
    <s:iterationstrategy>
      <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="input" />
        <i:iterator name="copy_number" />
      </i:dot>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="CloneStringToList_DocumentInstance">
    <s:beanshell>
      <s:scriptvalue>import java.util.*;

List newlist = new ArrayList();

for (int i=0; i&lt;((int) Integer.parseInt(copy_number.toString())); i++) {
	newlist.add(input);
}

clones=newlist;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">copy_number</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="l('text/plain')">clones</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
    <s:iterationstrategy>
      <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="input" />
        <i:iterator name="copy_number" />
      </i:dot>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="CloneStringToList_NERprocessRunInstance">
    <s:beanshell>
      <s:scriptvalue>import java.util.*;

List newlist = new ArrayList();

for (int i=0; i&lt;((int) Integer.parseInt(copy_number.toString())); i++) {
	newlist.add(input);
}

clones=newlist;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/plain'">copy_number</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="l('text/plain')">clones</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
    <s:iterationstrategy>
      <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="input" />
        <i:iterator name="copy_number" />
      </i:dot>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="Timestamp">
    <s:beanshell>
      <s:scriptvalue>/*
provides current date and time in various formats
no inputs
output:
now_RFC822
now_short
now_ISO8601
*/
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

DateFormat dateFormatRFC822 = new SimpleDateFormat("EEE', 'dd' 'MMM' 'yyyy' 'HH':'mm':'ss' 'z");
DateFormat dateFormatISO8601 = new SimpleDateFormat("yyyy'-'MM'-'dd'T'HH':'mm':'ssZ");
DateFormat dateFormatShort = new SimpleDateFormat("yyMMdd_HHmmss");

Date date = new Date();

String tmp_ISO8601 = (String) dateFormatISO8601.format(date);
tmp_ISO8601 = tmp_ISO8601.substring(0,tmp_ISO8601.length()-2) + ":" + tmp_ISO8601.substring(tmp_ISO8601.length()-2);

now_RFC822=dateFormatRFC822.format(date);
now_ISO8601 = tmp_ISO8601;
now_short=dateFormatShort.format(date);</s:scriptvalue>
      <s:beanshellinputlist />
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/plain'">now_RFC822</s:beanshelloutput>
        <s:beanshelloutput s:syntactictype="'text/plain'">now_short</s:beanshelloutput>
        <s:beanshelloutput s:syntactictype="'text/plain'">now_ISO8601</s:beanshelloutput>
      </s:beanshelloutputlist>
      <s:dependencies s:classloader="iteration" />
    </s:beanshell>
  </s:processor>
  <s:processor name="s07_AddScoreToSemanticModel">
    <s:description>Add ranking score for discovered protein terms to the semantic model.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:f642ee66-0236-4222-820b-e45b4f33b923" author="Marco Roos (workfllow), Willem R. van Hage (services)" title="AddScoreToSemanticModel">Add Likelihood Score  to Semantic model with Sesame service cf example Score</s:workflowdescription>
        <s:processor name="LikelihoodDiscoveryScore" boring="true">
          <s:stringconstant>LikelihoodDiscoveryScore_</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_TextMining__DiscoveryScore" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#DiscoveryScore</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_TextMining__has_discovery_score" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_discovery_score</s:stringconstant>
        </s:processor>
        <s:processor name="Data_081028_171550__Protoontology_TextMining__discovery_score_value" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovery_score_value</s:stringconstant>
        </s:processor>
        <s:processor name="xsd_double" boring="true">
          <s:stringconstant>http://www.w3.org/2001/XMLSchema#double</s:stringconstant>
        </s:processor>
        <s:processor name="InstantiateDiscoveryScore">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "1999-05-31T13:20:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime

output:
NTriple_InstanceOf_statement
instance_uri
*/

instance_uri = instance_ontology_url + "#" + instance_name;

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:dot>
                <i:iterator name="datetime" />
                <i:iterator name="comment_string" />
                <i:iterator name="type_uri" />
                <i:iterator name="instance_ontology_url" />
              </i:dot>
              <i:dot>
                <i:iterator name="label_string" />
                <i:iterator name="instance_name" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="DefineHasDiscoveryScoreRelation">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="relation_uri" />
              <i:dot>
                <i:iterator name="range_instance_uri" />
                <i:iterator name="domain_instance_uri" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="DiscoveryScoreName">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="DefineTypedPropertyOfInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
property_uri
property_string

output:
NTriple_PropertyOfInstance_statement
*/

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ property_uri + "&gt; \"" + property_string + "\"^^&lt;" + property_type + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_type</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="property_uri" />
              <i:iterator name="property_type" />
              <i:dot>
                <i:iterator name="property_string" />
                <i:iterator name="instance_uri" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="save_as">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="Data_081028_171550__Protoontology_TextMining__discovery_score_value:value" sink="DefineTypedPropertyOfInstance:property_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_TextMining__has_discovery_score:value" sink="DefineHasDiscoveryScoreRelation:relation_uri" />
        <s:link source="cls_081028_171550__Protoontology_TextMining__DiscoveryScore:value" sink="InstantiateDiscoveryScore:type_uri" />
        <s:link source="discovered_instance_uri" sink="DefineHasDiscoveryScoreRelation:domain_instance_uri" />
        <s:link source="instance_ontology_url" sink="InstantiateDiscoveryScore:instance_ontology_url" />
        <s:link source="InstantiateDiscoveryScore:instance_uri" sink="DefineHasDiscoveryScoreRelation:range_instance_uri" />
        <s:link source="InstantiateDiscoveryScore:instance_uri" sink="DefineTypedPropertyOfInstance:instance_uri" />
        <s:link source="LikelihoodDiscoveryScore:value" sink="DiscoveryScoreName:string1" />
        <s:link source="score_value" sink="DefineTypedPropertyOfInstance:property_string" />
        <s:link source="score_value" sink="DiscoveryScoreName:string2" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="DiscoveryScoreName:output" sink="InstantiateDiscoveryScore:instance_name" />
        <s:link source="DiscoveryScoreName:output" sink="InstantiateDiscoveryScore:label_string" />
        <s:link source="datetime" sink="InstantiateDiscoveryScore:datetime" />
        <s:link source="discovery_score_method" sink="InstantiateDiscoveryScore:comment_string" />
        <s:link source="DefineHasDiscoveryScoreRelation:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineTypedPropertyOfInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateDiscoveryScore:NTriple_InstanceOf_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="tmp_rdf_doc_ref" sink="save_as:filename" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="xsd_double:value" sink="DefineTypedPropertyOfInstance:property_type" />
        <s:link source="InstantiateDiscoveryScore:instance_uri" sink="discovery_instance_uri" />
        <s:link source="save_as:save_asReturn" sink="tmp_rdf_output_doc_ref" />
        <s:source name="score_value" />
        <s:source name="discovered_instance_uri" />
        <s:source name="datetime" />
        <s:source name="instance_ontology_url" />
        <s:source name="discovery_score_method">
          <s:metadata>
            <s:description>Description of how the discovery score was calculated.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="tmp_rdf_doc_ref" />
        <s:sink name="discovery_instance_uri" />
        <s:sink name="tmp_rdf_output_doc_ref" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="tmp_rdf_doc_ref" />
        <i:iterator name="discovery_score_method" />
        <i:iterator name="instance_ontology_url" />
        <i:iterator name="datetime" />
        <i:dot>
          <i:iterator name="score_value" />
          <i:iterator name="discovered_instance_uri" />
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="s02_AddOriginalQueryToSemanticModel">
    <s:description>Add Query to Semantic model with Sesame service cf example Biological Query</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:2ca45a93-0d4d-4e5c-b305-240df4ae1d18" author="Marco Roos (workflow), Willem R. van Hage (service)" title="AddOriginalQueryToSemanticModel">Add original (user provided) query to Semantic model.</s:workflowdescription>
        <s:processor name="Data_080814_114703__Protoontology_TextMining__has_lucene_query" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query</s:stringconstant>
        </s:processor>
        <s:processor name="DocumentSearchQuery_id_part1" boring="true">
          <s:stringconstant>DocQry:</s:stringconstant>
        </s:processor>
        <s:processor name="QueryInstanceComment" boring="true">
          <s:stringconstant>input query for document retrieval</s:stringconstant>
        </s:processor>
        <s:processor name="QueryInstanceLabel" boring="true">
          <s:stringconstant>original query</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080814_114703__Protoontology_MappingBioTextMining__partially_represents" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#partially_represents</s:stringconstant>
        </s:processor>
        <s:processor name="Data_080814_114703__Protoontology_TextMining__is_user_original" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#is_user_original</s:stringconstant>
        </s:processor>
        <s:processor name="cls_080814_114703__Protoontology_TextMining__DocumentSearchQuery" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#DocumentSearchQuery</s:stringconstant>
        </s:processor>
        <s:processor name="DefinePropertyOfInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
property_uri
property_string

output:
NTriple_PropertyOfInstance_statement
*/

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ property_uri + "&gt; \"" + property_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="is_user_provided_original" boring="true">
          <s:stringconstant>true</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="InstantiateQueryInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label, comment, and date
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "2008-08-14T14:37:29+02:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime // must be in the right format, cf. 2008-08-14T14:37:29+02:00 (yyyy-MM-ddTHH:mm:ssZ); NB 'Z' for timezone with Java's SimpleDateFormat omits the last colon which is required.

output:
NTriple_InstanceOf_statement
instance_uri
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

instance_uri = instance_ontology_url + "#" + instance_name;

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ConcatenateRDFstatements">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="ReplaceCharsForQueryID">
          <s:beanshell>
            <s:scriptvalue>/*
replace characters that Protégé does not like for names
*/

import java.util.regex.*;
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

String tmpstring = input;
/*
Pattern p = Pattern.compile("#");
Matcher m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;hash;");

p = Pattern.compile("\\^");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;caret;");

p = Pattern.compile("&lt;");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;lt;");

p = Pattern.compile("&gt;");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;gt;");

p = Pattern.compile("\\{");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;lcurly;");

p = Pattern.compile("\\}");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;rcurly;");

p = Pattern.compile("%");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;perc;");

p = Pattern.compile("_");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;ndash;");

p = Pattern.compile("\"");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;quot;");

p = Pattern.compile("\\s");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("_");
*/

output = URLEncoder.encode(tmpstring, "UTF-8");</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="SlashDoubleQuotes">
          <s:defaults>
            <s:default name="findstring">"</s:default>
            <s:default name="replacestring">\\\"</s:default>
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>import java.util.regex.*;

Pattern p = Pattern.compile(findstring);
Matcher m = p.matcher(input);

output = (String) m.replaceAll(replacestring);</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">findstring</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">replacestring</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineBooleanPropertyOfInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
property_uri
property_string

output:
NTriple_PropertyOfInstance_statement
*/

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ property_uri + "&gt; \"" + property_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_string</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Concat">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="append">no</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="ConcatenateRDFstatements:output" sink="save_as:content" />
        <s:link source="Data_080814_114703__Protoontology_TextMining__has_lucene_query:value" sink="DefinePropertyOfInstance:property_uri" />
        <s:link source="Data_080814_114703__Protoontology_TextMining__is_user_original:value" sink="DefineBooleanPropertyOfInstance:property_uri" />
        <s:link source="DefineBooleanPropertyOfInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="DefinePropertyOfInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="DefineSemanticRelation:NTriple_Relation_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="DocumentSearchQuery_id_part1:value" sink="Concat:string1" />
        <s:link source="InstanceOntologyURL" sink="InstantiateQueryInstance:instance_ontology_url" />
        <s:link source="RDF_doc_filename" sink="save_as:filename" />
        <s:link source="query" sink="ReplaceCharsForQueryID:input" />
        <s:link source="query" sink="SlashDoubleQuotes:input" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="Concat:output" sink="InstantiateQueryInstance:instance_name" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefineBooleanPropertyOfInstance:instance_uri" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefinePropertyOfInstance:instance_uri" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefineSemanticRelation:domain_instance_uri" />
        <s:link source="ObjProp_080814_114703__Protoontology_MappingBioTextMining__partially_represents:value" sink="DefineSemanticRelation:relation_uri" />
        <s:link source="QueryInstanceComment:value" sink="InstantiateQueryInstance:comment_string" />
        <s:link source="QueryInstanceLabel:value" sink="InstantiateQueryInstance:label_string" />
        <s:link source="ReplaceCharsForQueryID:output" sink="Concat:string2" />
        <s:link source="SlashDoubleQuotes:output" sink="DefinePropertyOfInstance:property_string" />
        <s:link source="cls_080814_114703__Protoontology_TextMining__DocumentSearchQuery:value" sink="InstantiateQueryInstance:type_uri" />
        <s:link source="datetime" sink="InstantiateQueryInstance:datetime" />
        <s:link source="model_instance_uri" sink="DefineSemanticRelation:range_instance_uri" />
        <s:link source="InstantiateQueryInstance:NTriple_InstanceOf_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="query_instance" />
        <s:link source="is_user_provided_original:value" sink="DefineBooleanPropertyOfInstance:property_string" />
        <s:link source="save_as:save_asReturn" sink="QueryRDFdoc_url" />
        <s:source name="query" />
        <s:source name="RDF_doc_filename">
          <s:metadata>
            <s:description>Reference to  file for RDF output.

E.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:source name="InstanceOntologyURL">
          <s:metadata>
            <s:description>Instance ontology URL. E.g. http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:description>
          </s:metadata>
        </s:source>
        <s:source name="model_instance_uri">
          <s:metadata>
            <s:description>e.g.
http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel</s:description>
          </s:metadata>
        </s:source>
        <s:source name="datetime">
          <s:metadata>
            <s:description>conform this format
2008-08-14T14:37:29+02:00</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="query_instance" />
        <s:sink name="QueryRDFdoc_url" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="02_RetrieveDocumentsFromMedline">
    <s:description>This workflow applies the search web service from the AIDA toolbox.

Comments:
This search service is based on lucene defaults; it may be necessary to optimize the querystring to adopt the behaviour to what is most relevant in a particular domain (e.g. for medline prioritizing based on publication date is useful). Lucene favours shorter sentences, which may be bad for subsequent information extraction.</s:description>
    <s:defaults>
      <s:default name="document_index">MedLine</s:default>
      <s:default name="search_field">content</s:default>
    </s:defaults>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:858efe24-26c0-4090-be46-c9a5b4f21cad" author="Marco Roos (workflow), Edgard Meij (service)" title="AIDA_Retrieve_documents_in_parts">This workflow applies the search web service from the AIDA toolbox.

Comments:
This search service is based on lucene defaults; it may be necessary to optimize the querystring to adopt the behaviour to what is most relevant in a particular domain (e.g. for medline prioritizing based on publication date is useful). Lucene favours shorter sentences, which may be bad for subsequent information extraction.</s:workflowdescription>
        <s:processor name="title_xpath" boring="true">
          <s:stringconstant>/aid:result/doc/field[@name='title']/value</s:stringconstant>
        </s:processor>
        <s:processor name="PubMedURL_stub" boring="true">
          <s:stringconstant>http&amp;#58;//www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&amp;amp;db=PubMed&amp;amp;list_uids=</s:stringconstant>
        </s:processor>
        <s:processor name="abstract_xpath" boring="true">
          <s:stringconstant>/aid:result/doc/field[@name='content']/value</s:stringconstant>
        </s:processor>
        <s:processor name="pubmedID_xpath" boring="true">
          <s:stringconstant>/aid:result/doc/field[@name='PMID']/value</s:stringconstant>
        </s:processor>
        <s:processor name="XPath_PMID">
          <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
        </s:processor>
        <s:processor name="SyncOutTitle">
          <s:description>Xpath returns a list, while concatenat doesn't; this syncronized the list level of all ouptuts.</s:description>
          <s:defaults>
            <s:default name="string2" />
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="SyncOutAbstract">
          <s:description>Xpath returns a list, while concatenat doesn't; this syncronized the list level of all ouptuts.</s:description>
          <s:defaults>
            <s:default name="string2" />
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="SyncOutPMID">
          <s:description>Xpath returns a list, while concatenat doesn't; this syncronized the list level of all ouptuts.</s:description>
          <s:defaults>
            <s:default name="string2" />
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="Concatenate2">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
          <s:iterationstrategy>
            <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="string2" />
              <i:iterator name="string1" />
            </i:dot>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="XPath_Abstract">
          <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
        </s:processor>
        <s:processor name="XPath_Title">
          <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
        </s:processor>
        <s:processor name="Concatenate1">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="search">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/services/SearcherWS?wsdl</s:wsdl>
            <s:operation>search</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="document_index" sink="search:index" />
        <s:link source="maxHits" sink="search:maxHits" />
        <s:link source="queryString" sink="search:queryString" />
        <s:link source="search_field" sink="search:defaultField" />
        <s:link source="PubMedURL_stub:value" sink="Concatenate1:string1" />
        <s:link source="SyncOutAbstract:output" sink="abstract" />
        <s:link source="XPath_Abstract:nodelist" sink="Concatenate2:string2" />
        <s:link source="XPath_Abstract:nodelist" sink="SyncOutAbstract:string1" />
        <s:link source="XPath_PMID:nodelist" sink="Concatenate1:string2" />
        <s:link source="XPath_PMID:nodelist" sink="SyncOutPMID:string1" />
        <s:link source="XPath_Title:nodelist" sink="Concatenate2:string1" />
        <s:link source="XPath_Title:nodelist" sink="SyncOutTitle:string1" />
        <s:link source="abstract_xpath:value" sink="XPath_Abstract:xpath" />
        <s:link source="pubmedID_xpath:value" sink="XPath_PMID:xpath" />
        <s:link source="search:searchReturn" sink="XPath_Abstract:xml-text" />
        <s:link source="search:searchReturn" sink="XPath_PMID:xml-text" />
        <s:link source="search:searchReturn" sink="XPath_Title:xml-text" />
        <s:link source="title_xpath:value" sink="XPath_Title:xpath" />
        <s:link source="Concatenate1:output" sink="pubmed_URL" />
        <s:link source="Concatenate2:output" sink="title_abstract" />
        <s:link source="SyncOutPMID:output" sink="pubmed_id" />
        <s:link source="SyncOutTitle:output" sink="title" />
        <s:source name="queryString">
          <s:metadata>
            <s:description>Lucene query for search. Simple AND and OR queries will work. For advanced queries see http://lucene.apache.org for more information.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="document_index">
          <s:metadata>
            <s:description>e.g. MedLine will give access to a weekly update index of the medline corpus.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="search_field">
          <s:metadata>
            <s:description>e.g.' content' will search abstract and title; abstract just the abstract, title just the title.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="maxHits">
          <s:metadata>
            <s:description>limits the maximum number of hits search will produce. In Taverna 1 '100' works well while a 1000 and above is likely to halt Taverna 1 due to memory problems. This also depends on the memory setting for the java virtual machine by the client (usually your local Taverna).</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="pubmed_id" />
        <s:sink name="pubmed_URL" />
        <s:sink name="abstract" />
        <s:sink name="title" />
        <s:sink name="title_abstract" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="p03_AddProteinDiscoveryToSemanticModel">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:5bd4f165-bc8e-4ec7-bd67-b08b256c000f" author="" title="AddProteinDiscoveryToSemanticModel" />
        <s:processor name="ObjProp_081028_171550__Protoontology_Workflow__computation_component_of_run" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#computation_component_of_run</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_TextMining__TextMiningProcessRun" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#TextMiningProcessRun</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="Inst_081028_171550__Protoontology_AIDA_Instances__AIDA_CombinedProteinTermExtractionProcess" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl#AIDA_CombinedProteinTermExtractionProcess</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_Workflow__ComputationRun" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#ComputationRun</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_TextMining__run_of_process" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#run_of_process</s:stringconstant>
        </s:processor>
        <s:processor name="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_CRFNamedEntityRecognitionService" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl#AIDA_CRFNamedEntityRecognitionService</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_MappingBioTextMining__process_run_performed_by_computation_run" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#process_run_performed_by_computation_run</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_Workflow__computation_run_of" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#computation_run_of</s:stringconstant>
        </s:processor>
        <s:processor name="DefineSemanticRelationRunComponent">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="domain_instance_uri" mode="merge" />
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:dot>
                <i:iterator name="relation_uri" />
                <i:iterator name="range_instance_uri" />
              </i:dot>
              <i:iterator name="domain_instance_uri" />
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="InstantiateRunOfNERProcessAndService">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Process and Service runs including label and comment and their interrelationship
*/

/*
input:
instance_ontology_url
executed_process_instance_uri
executed_service_instance_uri
process_service_relation_uri
run_of_process_property_uri
run_of_service_property_uri
process_run_type_uri
service_run_type_uri
datetime
timestamp_shortstring
input

output:
NTriple_statements
process_run_instance_uri;
service_run_instance_uri;
*/

String[] tmp;
String executed_instance_uri;
String executed_name;
String instance_name;
String type_uri;

NTriple_statements = "";

int i=0;
while (i&lt;=1) {
	if (i==0) {
		executed_instance_uri = executed_process_instance_uri;
		run_of_property_uri = run_of_process_property_uri;
		type_uri = process_run_type_uri;
	} else {
		executed_instance_uri = executed_service_instance_uri;
		run_of_property_uri = run_of_service_property_uri;
		type_uri = service_run_type_uri;
	}

	tmp = executed_instance_uri.split("#", 2);
	executed_name = tmp[1].toString();
	instance_name = executed_name + "_run_on_" + input + "_at_" + timestamp_shortstring;
	instance_uri = instance_ontology_url + "#" + instance_name;
	if (i==0) { process_run_instance_uri = instance_uri; } else { service_run_instance_uri = instance_uri; }

	String comment_string = "run of " + executed_instance_uri + " on "  + input + " dd. " + datetime + ".";
	String label_string = "run of " + executed_name + " on " + input + " at " + timestamp_shortstring;

	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";
	
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;" + run_of_property_uri + "&gt; &lt;" + executed_instance_uri + "&gt; .\n";

	i=i+1;
}

NTriple_statements = NTriple_statements + "&lt;" + process_run_instance_uri + "&gt; &lt;" + process_service_relation_uri + "&gt; &lt;" + service_run_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">timestamp_shortstring</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">executed_service_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">executed_process_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">process_service_relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">run_of_process_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">run_of_service_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">process_run_type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">service_run_type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_statements</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">process_run_instance_uri</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">service_run_instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="input" />
              <i:dot>
                <i:iterator name="service_run_type_uri" />
                <i:iterator name="process_run_type_uri" />
                <i:iterator name="run_of_service_property_uri" />
                <i:iterator name="run_of_process_property_uri" />
                <i:iterator name="process_service_relation_uri" />
                <i:iterator name="executed_process_instance_uri" />
                <i:iterator name="executed_service_instance_uri" />
                <i:iterator name="timestamp_shortstring" />
                <i:iterator name="datetime" />
                <i:iterator name="instance_ontology_url" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="append">no</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="instance_ontology_url" sink="InstantiateRunOfNERProcessAndService:instance_ontology_url" />
        <s:link source="timestamp_iso8601" sink="InstantiateRunOfNERProcessAndService:datetime" />
        <s:link source="timestamp_shortstring" sink="InstantiateRunOfNERProcessAndService:timestamp_shortstring" />
        <s:link source="tmp_RDFdoc_fileref" sink="save_as:filename" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_CRFNamedEntityRecognitionService:value" sink="InstantiateRunOfNERProcessAndService:executed_service_instance_uri" />
        <s:link source="Inst_081028_171550__Protoontology_AIDA_Instances__AIDA_CombinedProteinTermExtractionProcess:value" sink="InstantiateRunOfNERProcessAndService:executed_process_instance_uri" />
        <s:link source="InstantiateRunOfNERProcessAndService:NTriple_statements" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateRunOfNERProcessAndService:service_run_instance_uri" sink="DefineSemanticRelationRunComponent:domain_instance_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_MappingBioTextMining__process_run_performed_by_computation_run:value" sink="InstantiateRunOfNERProcessAndService:process_service_relation_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_TextMining__run_of_process:value" sink="InstantiateRunOfNERProcessAndService:run_of_process_property_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_Workflow__computation_component_of_run:value" sink="DefineSemanticRelationRunComponent:relation_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_Workflow__computation_run_of:value" sink="InstantiateRunOfNERProcessAndService:run_of_service_property_uri" />
        <s:link source="cls_081028_171550__Protoontology_TextMining__TextMiningProcessRun:value" sink="InstantiateRunOfNERProcessAndService:process_run_type_uri" />
        <s:link source="cls_081028_171550__Protoontology_Workflow__ComputationRun:value" sink="InstantiateRunOfNERProcessAndService:service_run_type_uri" />
        <s:link source="computation_input" sink="InstantiateRunOfNERProcessAndService:input" />
        <s:link source="workflow_run_instance_uri" sink="DefineSemanticRelationRunComponent:range_instance_uri" />
        <s:link source="InstantiateRunOfNERProcessAndService:process_run_instance_uri" sink="AIDA_NERProcessRun_instance" />
        <s:link source="InstantiateRunOfNERProcessAndService:service_run_instance_uri" sink="AIDA_NERserviceRun_instance" />
        <s:link source="save_as:save_asReturn" sink="rdf_doc_url" />
        <s:source name="instance_ontology_url" />
        <s:source name="tmp_RDFdoc_fileref" />
        <s:source name="timestamp_iso8601" />
        <s:source name="timestamp_shortstring" />
        <s:source name="computation_input" />
        <s:source name="workflow_run_instance_uri" />
        <s:sink name="rdf_doc_url" />
        <s:sink name="AIDA_NERProcessRun_instance" />
        <s:sink name="AIDA_NERserviceRun_instance" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:dot>
          <i:iterator name="workflow_run_instance_uri" />
          <i:iterator name="timestamp_shortstring" />
          <i:iterator name="timestamp_iso8601" />
          <i:iterator name="tmp_RDFdoc_fileref" />
          <i:iterator name="instance_ontology_url" />
        </i:dot>
        <i:iterator name="computation_input" />
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="p02_AddDocumentDiscoveryToSemanticModel">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:5bd4f165-bc8e-4ec7-bd67-b08b256c000f" author="" title="AddDocumentDiscoveryToSemanticModel" />
        <s:processor name="ObjProp_081028_171550__Protoontology_MappingBioTextMining__process_run_performed_by_computation_run" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#process_run_performed_by_computation_run</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_TextMining__run_of_process" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#run_of_process</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_TextMining__TextMiningProcessRun" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#TextMiningProcessRun</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_Workflow__computation_run_of" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#computation_run_of</s:stringconstant>
        </s:processor>
        <s:processor name="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_LuceneBasedMedLineDocumentRetrievalProcess" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl#AIDA_LuceneBasedMedLineDocumentRetrievalProcess</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_Workflow__computation_component_of_run" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#computation_component_of_run</s:stringconstant>
        </s:processor>
        <s:processor name="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_DocumentRetrievalService" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl#AIDA_DocumentRetrievalService</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_Workflow__ComputationRun" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#ComputationRun</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="DefineSemanticRelationRunComponent">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="domain_instance_uri" mode="merge" />
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:dot>
                <i:iterator name="relation_uri" />
                <i:iterator name="range_instance_uri" />
              </i:dot>
              <i:iterator name="domain_instance_uri" />
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="InstantiateRunOfDocRetrProcessAndService">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Process and Service runs including label and comment and their interrelationship
*/

/*
input:
instance_ontology_url
executed_process_instance_uri
executed_service_instance_uri
process_service_relation_uri
run_of_process_property_uri
run_of_service_property_uri
process_run_type_uri
service_run_type_uri
datetime
timestamp_shortstring
input

output:
NTriple_statements
process_run_instance_uri;
service_run_instance_uri;
*/

String[] tmp;
String executed_instance_uri;
String executed_name;
String instance_name;
String type_uri;

NTriple_statements = "";

int i=0;
while (i&lt;=1) {
	if (i==0) {
		executed_instance_uri = executed_process_instance_uri;
		run_of_property_uri = run_of_process_property_uri;
		type_uri = process_run_type_uri;
	} else {
		executed_instance_uri = executed_service_instance_uri;
		run_of_property_uri = run_of_service_property_uri;
		type_uri = service_run_type_uri;
	}

	tmp = executed_instance_uri.split("#", 2);
	executed_name = tmp[1].toString();
	instance_name = executed_name + "_run_on_" + input + "_at_" + timestamp_shortstring;
	instance_uri = instance_ontology_url + "#" + instance_name;
	if (i==0) { process_run_instance_uri = instance_uri; } else { service_run_instance_uri = instance_uri; }

	String comment_string = "run of " + executed_instance_uri + " dd. " + datetime + ".";
	String label_string = "run of " + executed_name + " on " + timestamp_shortstring;

	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";
	
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;" + run_of_property_uri + "&gt; &lt;" + executed_instance_uri + "&gt; .\n";

	i=i+1;
}

NTriple_statements = NTriple_statements + "&lt;" + process_run_instance_uri + "&gt; &lt;" + process_service_relation_uri + "&gt; &lt;" + service_run_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">timestamp_shortstring</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">executed_service_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">executed_process_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">process_service_relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">run_of_process_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">run_of_service_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">process_run_type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">service_run_type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_statements</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">process_run_instance_uri</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">service_run_instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="input" />
              <i:dot>
                <i:iterator name="datetime" />
                <i:iterator name="service_run_type_uri" />
                <i:iterator name="process_run_type_uri" />
                <i:iterator name="run_of_service_property_uri" />
                <i:iterator name="run_of_process_property_uri" />
                <i:iterator name="executed_process_instance_uri" />
                <i:iterator name="process_service_relation_uri" />
                <i:iterator name="executed_service_instance_uri" />
                <i:iterator name="timestamp_shortstring" />
                <i:iterator name="instance_ontology_url" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="append">no</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="instance_ontology_url" sink="InstantiateRunOfDocRetrProcessAndService:instance_ontology_url" />
        <s:link source="timestamp_iso8601" sink="InstantiateRunOfDocRetrProcessAndService:datetime" />
        <s:link source="timestamp_shortstring" sink="InstantiateRunOfDocRetrProcessAndService:timestamp_shortstring" />
        <s:link source="tmp_RDFdoc_fileref" sink="save_as:filename" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_DocumentRetrievalService:value" sink="InstantiateRunOfDocRetrProcessAndService:executed_service_instance_uri" />
        <s:link source="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_LuceneBasedMedLineDocumentRetrievalProcess:value" sink="InstantiateRunOfDocRetrProcessAndService:executed_process_instance_uri" />
        <s:link source="InstantiateRunOfDocRetrProcessAndService:NTriple_statements" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateRunOfDocRetrProcessAndService:service_run_instance_uri" sink="DefineSemanticRelationRunComponent:domain_instance_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_MappingBioTextMining__process_run_performed_by_computation_run:value" sink="InstantiateRunOfDocRetrProcessAndService:process_service_relation_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_TextMining__run_of_process:value" sink="InstantiateRunOfDocRetrProcessAndService:run_of_process_property_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_Workflow__computation_component_of_run:value" sink="DefineSemanticRelationRunComponent:relation_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_Workflow__computation_run_of:value" sink="InstantiateRunOfDocRetrProcessAndService:run_of_service_property_uri" />
        <s:link source="cls_081028_171550__Protoontology_TextMining__TextMiningProcessRun:value" sink="InstantiateRunOfDocRetrProcessAndService:process_run_type_uri" />
        <s:link source="cls_081028_171550__Protoontology_Workflow__ComputationRun:value" sink="InstantiateRunOfDocRetrProcessAndService:service_run_type_uri" />
        <s:link source="workflow_run_instance_uri" sink="DefineSemanticRelationRunComponent:range_instance_uri" />
        <s:link source="DefineSemanticRelationRunComponent:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="computation_input" sink="InstantiateRunOfDocRetrProcessAndService:input" />
        <s:link source="InstantiateRunOfDocRetrProcessAndService:process_run_instance_uri" sink="AIDA_DocRetrProcessRun_instance" />
        <s:link source="InstantiateRunOfDocRetrProcessAndService:service_run_instance_uri" sink="AIDA_DocRetrServiceRun_instance" />
        <s:link source="save_as:save_asReturn" sink="workflow_rdf_doc_url" />
        <s:source name="instance_ontology_url" />
        <s:source name="tmp_RDFdoc_fileref" />
        <s:source name="timestamp_iso8601" />
        <s:source name="timestamp_shortstring" />
        <s:source name="workflow_run_instance_uri">
          <s:metadata>
            <s:description>The run of a computation component that the document retrieval service runs are component parts of.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="computation_input">
          <s:metadata>
            <s:description>Input that triggered the service and process to run (a unique identifier for each run)</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="workflow_rdf_doc_url" />
        <s:sink name="AIDA_DocRetrProcessRun_instance" />
        <s:sink name="AIDA_DocRetrServiceRun_instance" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="computation_input" />
        <i:dot>
          <i:iterator name="workflow_run_instance_uri" />
          <i:iterator name="timestamp_shortstring" />
          <i:iterator name="timestamp_iso8601" />
          <i:iterator name="tmp_RDFdoc_fileref" />
          <i:iterator name="instance_ontology_url" />
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="s03b_AddQueryProteinsToSemanticModel">
    <s:description>Add Protein to Semantic model with Sesame service cf example Discovered Proteins</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:fd7d0d06-932c-45cc-af4a-3d301b0a5a9f" author="Marco Roos (workflow), Willem R. van Hage (services)" title="AddQueryProteinToSemanticModel">Add Protein to Semantic model with Sesame service cf example Discovered Proteins</s:workflowdescription>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_iHopQueryURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_iHopQueryURI</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_ExpasyUniProtURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_ExpasyUniProtURI</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_EntrezUniProtURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_EntrezUniProtURI</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_BioModel__isModelComponentOf" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#isModelComponentOf</s:stringconstant>
        </s:processor>
        <s:processor name="DefineSeeAlsoEntrezUniprotForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSeeAlsoiHopForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="InstantiateSemanticType_Protein">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "1999-05-31T13:20:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime

output:
NTriple_InstanceOf_statement
instance_uri
*/

instance_uri = instance_ontology_url + "#" + instance_name;

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSeeAlsoiHopQueryForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_isModelComponent">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_references">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSeeAlsoExpasyForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="InstantiateSemanticType_ProteinTerm">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "1999-05-31T13:20:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime

output:
NTriple_InstanceOf_statement
instance_uri
*/

instance_uri = instance_ontology_url + "#" + instance_name;

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ProteinTermAnnotations">
          <s:beanshell>
            <s:scriptvalue>/*
input:
protein_name
uniprot_id

output:
protein_label
protein_comment
protein_term_label
protein_term_comment
*/

if(uniprot_id.length()&gt;0) {
	protein_label = protein_name + "_" + uniprot_id;
	protein_comment = "protein referred to by as " + protein_name + " and UniProt ID: " + uniprot_id;
	protein_term_comment = "protein term " + protein_name + ", identified as name of protein with UniProt ID: " + uniprot_id;
} else {
	protein_label = protein_name; // flawed assumption that proteins without a uniprot id can be identified by their name
	protein_comment = "protein referred to by as " + protein_name + " without a rat, mouse, or human UniProt ID";
	protein_term_comment = "protein term " + protein_name + " as name of protein without rat, mouse, or human UniProt identifier";
}

protein_term_label = protein_label;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">protein_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">uniprot_id</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_label</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_comment</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_term_label</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_term_comment</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="cls_080814_114703__Protoontology_Text__ProteinTerm" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Text.owl#ProteinTerm</s:stringconstant>
        </s:processor>
        <s:processor name="cls_080814_114703__Protoontology_BioModel__Protein" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Protein</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_iHopUniProtURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_iHopUniProtURI</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080814_114703__Protoontology_MappingBioTextMining__references" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#references</s:stringconstant>
        </s:processor>
        <s:processor name="save_as">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="expasy_URL" sink="DefineSeeAlsoExpasyForInstance:seeAlso_url" />
        <s:link source="protein_name" sink="InstantiateSemanticType_ProteinTerm:instance_name" />
        <s:link source="uniprot_id" sink="InstantiateSemanticType_Protein:instance_name" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_EntrezUniProtURI:value" sink="DefineSeeAlsoEntrezUniprotForInstance:annotation_property_uri" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_ExpasyUniProtURI:value" sink="DefineSeeAlsoExpasyForInstance:annotation_property_uri" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_iHopQueryURI:value" sink="DefineSeeAlsoiHopQueryForInstance:annotation_property_uri" />
        <s:link source="DefineSeeAlsoEntrezUniprotForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSeeAlsoExpasyForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoExpasyForInstance:instance_uri" />
        <s:link source="cls_080814_114703__Protoontology_BioModel__Protein:value" sink="InstantiateSemanticType_Protein:type_uri" />
        <s:link source="cls_080814_114703__Protoontology_Text__ProteinTerm:value" sink="InstantiateSemanticType_ProteinTerm:type_uri" />
        <s:link source="entrez_pubmed_URL" sink="DefineSeeAlsoEntrezUniprotForInstance:seeAlso_url" />
        <s:link source="protein_name" sink="ProteinTermAnnotations:protein_name" />
        <s:link source="uniprot_id" sink="ProteinTermAnnotations:uniprot_id" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoEntrezUniprotForInstance:instance_uri" />
        <s:link source="ProteinTermAnnotations:protein_comment" sink="InstantiateSemanticType_Protein:comment_string" />
        <s:link source="ProteinTermAnnotations:protein_label" sink="InstantiateSemanticType_Protein:label_string" />
        <s:link source="ProteinTermAnnotations:protein_term_comment" sink="InstantiateSemanticType_ProteinTerm:comment_string" />
        <s:link source="ProteinTermAnnotations:protein_term_label" sink="InstantiateSemanticType_ProteinTerm:label_string" />
        <s:link source="datetime" sink="InstantiateSemanticType_Protein:datetime" />
        <s:link source="datetime" sink="InstantiateSemanticType_ProteinTerm:datetime" />
        <s:link source="iHop_search_URL" sink="DefineSeeAlsoiHopQueryForInstance:seeAlso_url" />
        <s:link source="instance_ontology_url" sink="InstantiateSemanticType_Protein:instance_ontology_url" />
        <s:link source="instance_ontology_url" sink="InstantiateSemanticType_ProteinTerm:instance_ontology_url" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_iHopUniProtURI:value" sink="DefineSeeAlsoiHopForInstance:annotation_property_uri" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="DefineSeeAlsoiHopQueryForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSemanticRelation_isModelComponent:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSemanticRelation_references:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:NTriple_InstanceOf_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoiHopForInstance:instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoiHopQueryForInstance:instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSemanticRelation_references:range_instance_uri" />
        <s:link source="InstantiateSemanticType_ProteinTerm:NTriple_InstanceOf_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="DefineSemanticRelation_references:domain_instance_uri" />
        <s:link source="ObjProp_080814_114703__Protoontology_MappingBioTextMining__references:value" sink="DefineSemanticRelation_references:relation_uri" />
        <s:link source="iHop_sentence_URL" sink="DefineSeeAlsoiHopForInstance:seeAlso_url" />
        <s:link source="tmp_rdf_output_fileref" sink="save_as:filename" />
        <s:link source="DefineSeeAlsoiHopForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSemanticRelation_isModelComponent:domain_instance_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_BioModel__isModelComponentOf:value" sink="DefineSemanticRelation_isModelComponent:relation_uri" />
        <s:link source="model_instance_uri" sink="DefineSemanticRelation_isModelComponent:range_instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="protein_instance" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="protein_term_instance" />
        <s:link source="save_as:save_asReturn" sink="output_doc_ref" />
        <s:source name="protein_name">
          <s:metadata>
            <s:description>E.g.
EZH2</s:description>
          </s:metadata>
        </s:source>
        <s:source name="uniprot_id">
          <s:metadata>
            <s:description>e.g.
Q15910</s:description>
          </s:metadata>
        </s:source>
        <s:source name="model_instance_uri" />
        <s:source name="entrez_pubmed_URL">
          <s:metadata>
            <s:description>http://www.ncbi.nlm.nih.gov/pubmed/</s:description>
          </s:metadata>
        </s:source>
        <s:source name="expasy_URL">
          <s:metadata>
            <s:description>http://www.expasy.ch/</s:description>
          </s:metadata>
        </s:source>
        <s:source name="iHop_sentence_URL" />
        <s:source name="iHop_search_URL" />
        <s:source name="instance_ontology_url">
          <s:metadata>
            <s:description>E.g.
http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:description>
          </s:metadata>
        </s:source>
        <s:source name="datetime">
          <s:metadata>
            <s:description>E.g.
2008-08-14T14:37:29+02:00</s:description>
          </s:metadata>
        </s:source>
        <s:source name="tmp_rdf_output_fileref">
          <s:metadata>
            <s:description>E.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="protein_instance" />
        <s:sink name="output_doc_ref" />
        <s:sink name="protein_term_instance" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="tmp_rdf_output_fileref" />
        <i:dot>
          <i:iterator name="datetime" />
          <i:iterator name="model_instance_uri" />
          <i:iterator name="instance_ontology_url" />
        </i:dot>
        <i:dot>
          <i:iterator name="uniprot_id" />
          <i:iterator name="protein_name" />
          <i:dot>
            <i:iterator name="expasy_URL" />
            <i:iterator name="iHop_search_URL" />
            <i:iterator name="iHop_sentence_URL" />
            <i:iterator name="entrez_pubmed_URL" />
          </i:dot>
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="01b_UniProtXrefURLs">
    <s:description>Adds URL cross references to various protein information resources.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:c0a963bc-2343-4d31-aa8c-304bfe3a6289" author="Marco Roos (workflow)" title="XrefUniprot_HomoSapiens">Adds URL cross references to various protein information resources.</s:workflowdescription>
        <s:processor name="EntrezPubMedUniProtURL_stub" boring="true">
          <s:stringconstant>http&amp;#58;//www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&amp;val=</s:stringconstant>
        </s:processor>
        <s:processor name="ConcatenateEntrezURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="Concatenate_iHopURL_preStub">
          <s:defaults>
            <s:default name="string1">http&amp;#58;//www.ihop-net.org/UniPub/iHOP/gismo/</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="Concatenate_iHopURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="iHopSentenceURL_poststub" boring="true">
          <s:stringconstant>.html?ORGANISM_ID=1</s:stringconstant>
        </s:processor>
        <s:processor name="ExpasyUniProtURL_stub" boring="true">
          <s:stringconstant>http&amp;#58;//expasy.org/uniprot/</s:stringconstant>
        </s:processor>
        <s:processor name="iHopSearchURL_stub" boring="true">
          <s:stringconstant>http&amp;#58;//www.ihop-net.org/UniPub/iHOP/?field=UNIPROT__AC&amp;ncbi_tax_id=9606&amp;organism_syn=&amp;search=</s:stringconstant>
        </s:processor>
        <s:processor name="ExtractiHopRefByRegexp">
          <s:defaults>
            <s:default name="regex">&lt;iHOPguessedSymbolId query=\".+\" xmlns=\"http://www.pdg.cnb.uam.es/UniPub/iHOP/xml\"&gt;(.+)&lt;/iHOPguessedSymbolId&gt;</s:default>
            <s:default name="group">1</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.RegularExpressionStringList</s:local>
        </s:processor>
        <s:processor name="iHopSentenceURL_prestub" boring="true">
          <s:stringconstant>http&amp;#58;//www.ihop-net.org/UniPub/iHOP/gismo/</s:stringconstant>
        </s:processor>
        <s:processor name="Concatenate_iHopURL_postStub">
          <s:defaults>
            <s:default name="string2">.html?ORGANISM_ID=1</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="ConcatenateExpasyURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="guessSymbolIdFromReference">
          <s:description>It takes a biological database reference as input. It guess the iHOP Id which best matches with the input.</s:description>
          <s:arbitrarywsdl>
            <s:wsdl>http://ubio.bioinfo.cnio.es/biotools/iHOP/iHOP-SOAP.wsdl</s:wsdl>
            <s:operation>guessSymbolIdFromReference</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="UniProtID" sink="ConcatenateEntrezURL:string2" />
        <s:link source="UniProtID" sink="ConcatenateExpasyURL:string2" />
        <s:link source="UniProtID" sink="Concatenate_iHopURL:string2" />
        <s:link source="UniProtID" sink="guessSymbolIdFromReference:reference" />
        <s:link source="ConcatenateEntrezURL:output" sink="EntrezUniProtURL" />
        <s:link source="ConcatenateExpasyURL:output" sink="ExpasyUniProtURL" />
        <s:link source="Concatenate_iHopURL_preStub:output" sink="Concatenate_iHopURL_postStub:string1" />
        <s:link source="EntrezPubMedUniProtURL_stub:value" sink="ConcatenateEntrezURL:string1" />
        <s:link source="ExpasyUniProtURL_stub:value" sink="ConcatenateExpasyURL:string1" />
        <s:link source="ExtractiHopRefByRegexp:filteredlist" sink="Concatenate_iHopURL_preStub:string2" />
        <s:link source="guessSymbolIdFromReference:result" sink="ExtractiHopRefByRegexp:stringlist" />
        <s:link source="iHopSearchURL_stub:value" sink="Concatenate_iHopURL:string1" />
        <s:link source="iHopSentenceURL_poststub:value" sink="Concatenate_iHopURL_postStub:string2" />
        <s:link source="iHopSentenceURL_prestub:value" sink="Concatenate_iHopURL_preStub:string1" />
        <s:link source="Concatenate_iHopURL:output" sink="iHopSearchURL" />
        <s:link source="Concatenate_iHopURL_postStub:output" sink="iHopSentencesURL" />
        <s:source name="UniProtID">
          <s:metadata>
            <s:description>UniProt ID (for iHop a Human protein is expected)
E.g. Q15190</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="ExpasyUniProtURL" />
        <s:sink name="EntrezUniProtURL" />
        <s:sink name="iHopSearchURL">
          <s:metadata>
            <s:mimeTypes>
              <s:mimeType>text/xml</s:mimeType>
            </s:mimeTypes>
          </s:metadata>
        </s:sink>
        <s:sink name="iHopSentencesURL" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="s03_AddExpandedQueryToSemanticModel">
    <s:description>Add autamotically expanded query to Semantic model.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:2ca45a93-0d4d-4e5c-b305-240df4ae1d18" author="Marco Roos (workflow), Willem R. van Hage (service)" title="AddExpandedQueryToSemanticModel">Add autamotically expanded query to Semantic model.</s:workflowdescription>
        <s:processor name="Data_080814_114703__Protoontology_TextMining__has_lucene_query" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query</s:stringconstant>
        </s:processor>
        <s:processor name="DocumentSearchQuery_id_part1" boring="true">
          <s:stringconstant>DocQry:</s:stringconstant>
        </s:processor>
        <s:processor name="cls_080814_114703__Protoontology_TextMining__DocumentSearchQuery" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#DocumentSearchQuery</s:stringconstant>
        </s:processor>
        <s:processor name="is_user_provided_original" boring="true">
          <s:stringconstant>false</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080814_114703__Protoontology_MappingBioTextMining__partially_represents" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#partially_represents</s:stringconstant>
        </s:processor>
        <s:processor name="QueryInstanceComment" boring="true">
          <s:stringconstant>input query for document retrieval</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080814_114703__Protoontology_TextMining__expanded_query_of" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#expanded_query_of</s:stringconstant>
        </s:processor>
        <s:processor name="QueryInstanceLabel" boring="true">
          <s:stringconstant>expanded query</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="Data_080814_114703__Protoontology_TextMining__is_user_original" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#is_user_original</s:stringconstant>
        </s:processor>
        <s:processor name="ReplaceCharsForQueryID">
          <s:beanshell>
            <s:scriptvalue>/*
replace characters that Protégé does not like for names
*/

import java.util.regex.*;
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

String tmpstring = input;
/*
Pattern p = Pattern.compile("#");
Matcher m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;hash;");

p = Pattern.compile("\\^");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;caret;");

p = Pattern.compile("&lt;");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;lt;");

p = Pattern.compile("&gt;");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;gt;");

p = Pattern.compile("\\{");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;lcurly;");

p = Pattern.compile("\\}");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;rcurly;");

p = Pattern.compile("%");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;perc;");

p = Pattern.compile("_");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;ndash;");

p = Pattern.compile("\"");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;quot;");

p = Pattern.compile("\\s");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("_");
*/

output = URLEncoder.encode(tmpstring, "UTF-8");</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_expansion_of">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ConcatenateRDFstatements">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="DefinePropertyOfInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
property_uri
property_string

output:
NTriple_PropertyOfInstance_statement
*/

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ property_uri + "&gt; \"" + property_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_references">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="SlashDoubleQuotes">
          <s:defaults>
            <s:default name="findstring">"</s:default>
            <s:default name="replacestring">\\\"</s:default>
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>import java.util.regex.*;

Pattern p = Pattern.compile(findstring);
Matcher m = p.matcher(input);

output = (String) m.replaceAll(replacestring);</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">findstring</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">replacestring</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="InstantiateQueryInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label, comment, and date
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "2008-08-14T14:37:29+02:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime // must be in the right format, cf. 2008-08-14T14:37:29+02:00 (yyyy-MM-ddTHH:mm:ssZ); NB 'Z' for timezone with Java's SimpleDateFormat omits the last colon which is required.

output:
NTriple_InstanceOf_statement
instance_uri
*/

instance_uri = instance_ontology_url + "#" + instance_name;

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineBooleanPropertyOfInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
property_uri
property_string

output:
NTriple_PropertyOfInstance_statement
*/

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ property_uri + "&gt; \"" + property_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">property_string</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Concat">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="append">no</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="ConcatenateRDFstatements:output" sink="save_as:content" />
        <s:link source="Data_080814_114703__Protoontology_TextMining__has_lucene_query:value" sink="DefinePropertyOfInstance:property_uri" />
        <s:link source="Data_080814_114703__Protoontology_TextMining__is_user_original:value" sink="DefineBooleanPropertyOfInstance:property_uri" />
        <s:link source="DefineBooleanPropertyOfInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="DefinePropertyOfInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="DefineSemanticRelation_references:NTriple_Relation_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="DocumentSearchQuery_id_part1:value" sink="Concat:string1" />
        <s:link source="InstanceOntologyURL" sink="InstantiateQueryInstance:instance_ontology_url" />
        <s:link source="RDF_doc_filename" sink="save_as:filename" />
        <s:link source="query" sink="ReplaceCharsForQueryID:input" />
        <s:link source="query" sink="SlashDoubleQuotes:input" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="Concat:output" sink="InstantiateQueryInstance:instance_name" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefineBooleanPropertyOfInstance:instance_uri" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefinePropertyOfInstance:instance_uri" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefineSemanticRelation_references:domain_instance_uri" />
        <s:link source="ObjProp_080814_114703__Protoontology_MappingBioTextMining__partially_represents:value" sink="DefineSemanticRelation_references:relation_uri" />
        <s:link source="QueryInstanceComment:value" sink="InstantiateQueryInstance:comment_string" />
        <s:link source="QueryInstanceLabel:value" sink="InstantiateQueryInstance:label_string" />
        <s:link source="ReplaceCharsForQueryID:output" sink="Concat:string2" />
        <s:link source="SlashDoubleQuotes:output" sink="DefinePropertyOfInstance:property_string" />
        <s:link source="cls_080814_114703__Protoontology_TextMining__DocumentSearchQuery:value" sink="InstantiateQueryInstance:type_uri" />
        <s:link source="datetime" sink="InstantiateQueryInstance:datetime" />
        <s:link source="model_instance_uri" sink="DefineSemanticRelation_references:range_instance_uri" />
        <s:link source="InstantiateQueryInstance:NTriple_InstanceOf_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="original_query_instance_uri" sink="DefineSemanticRelation_expansion_of:range_instance_uri" />
        <s:link source="DefineSemanticRelation_expansion_of:NTriple_Relation_statement" sink="ConcatenateRDFstatements:stringlist" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="DefineSemanticRelation_expansion_of:domain_instance_uri" />
        <s:link source="InstantiateQueryInstance:instance_uri" sink="query_instance" />
        <s:link source="ObjProp_080814_114703__Protoontology_TextMining__expanded_query_of:value" sink="DefineSemanticRelation_expansion_of:relation_uri" />
        <s:link source="is_user_provided_original:value" sink="DefineBooleanPropertyOfInstance:property_string" />
        <s:link source="save_as:save_asReturn" sink="QueryRDFdoc_url" />
        <s:source name="query" />
        <s:source name="RDF_doc_filename">
          <s:metadata>
            <s:description>Reference to  file for RDF output.

E.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:source name="InstanceOntologyURL">
          <s:metadata>
            <s:description>Instance ontology URL. E.g. http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:description>
          </s:metadata>
        </s:source>
        <s:source name="model_instance_uri">
          <s:metadata>
            <s:description>e.g.
http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel</s:description>
          </s:metadata>
        </s:source>
        <s:source name="datetime">
          <s:metadata>
            <s:description>conform this format
2008-08-14T14:37:29+02:00</s:description>
          </s:metadata>
        </s:source>
        <s:source name="original_query_instance_uri" />
        <s:sink name="query_instance" />
        <s:sink name="QueryRDFdoc_url" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="p01_AddWorkflowToSemanticModel">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:5bd4f165-bc8e-4ec7-bd67-b08b256c000f" author="" title="AddWorkflowMetadataToSemanticModel" />
        <s:processor name="ObjProp_081028_171550__Protoontology_Workflow__computation_run_of" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#computation_run_of</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_TextMining__run_of_process" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#run_of_process</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_Workflow__ComputationRun" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#ComputationRun</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_081028_171550__Protoontology_MappingBioTextMining__process_run_performed_by_computation_run" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#process_run_performed_by_computation_run</s:stringconstant>
        </s:processor>
        <s:processor name="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_ProteinTermColocationExtractionProcess" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl#AIDA_ProteinTermColocationExtractionProcess</s:stringconstant>
        </s:processor>
        <s:processor name="cls_081028_171550__Protoontology_TextMining__TextMiningProcessRun" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#TextMiningProcessRun</s:stringconstant>
        </s:processor>
        <s:processor name="Inst_081028_142923__Protoontology_AIDA_Instances__BioAID_BioModellingSupportByProteinExtractionWorkflow" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl#BioAID_BioModellingSupportByProteinExtractionWorkflow</s:stringconstant>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="InstantiateRunOfTextMiningProcessAndWorkflow">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Process and Service runs including label and comment and their interrelationship
*/

/*
input:
instance_ontology_url
executed_process_instance_uri
executed_service_instance_uri
process_service_relation_uri
run_of_process_property_uri
run_of_service_property_uri
process_run_type_uri
service_run_type_uri
datetime
timestamp_shortstring
input

output:
NTriple_statements
process_run_instance_uri;
service_run_instance_uri;
*/

String[] tmp;
String executed_instance_uri;
String executed_name;
String instance_name;
String type_uri;

NTriple_statements = "";

int i=0;
while (i&lt;=1) {
	if (i==0) {
		executed_instance_uri = executed_process_instance_uri;
		run_of_property_uri = run_of_process_property_uri;
		type_uri = process_run_type_uri;
	} else {
		executed_instance_uri = executed_service_instance_uri;
		run_of_property_uri = run_of_service_property_uri;
		type_uri = service_run_type_uri;
	}

	tmp = executed_instance_uri.split("#", 2);
	executed_name = tmp[1].toString();
	instance_name = executed_name + "_run_on_" + input + "_at_" + timestamp_shortstring;
	instance_uri = instance_ontology_url + "#" + instance_name;
	if (i==0) { process_run_instance_uri = instance_uri; } else { service_run_instance_uri = instance_uri; }

	String comment_string = "run of " + executed_instance_uri + " on " + input + " dd. " + datetime + ".";
	String label_string = "run of " + executed_name + " on input " + input + " on " + timestamp_shortstring;

	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";
	
	NTriple_statements = NTriple_statements + "&lt;" + instance_uri + "&gt; &lt;" + run_of_property_uri + "&gt; &lt;" + executed_instance_uri + "&gt; .\n";

	i=i+1;
}

NTriple_statements = NTriple_statements + "&lt;" + process_run_instance_uri + "&gt; &lt;" + process_service_relation_uri + "&gt; &lt;" + service_run_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">timestamp_shortstring</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">executed_service_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">executed_process_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">process_service_relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">run_of_process_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">run_of_service_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">process_run_type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">service_run_type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_statements</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">process_run_instance_uri</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">service_run_instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="input" />
              <i:dot>
                <i:iterator name="service_run_type_uri" />
                <i:iterator name="process_run_type_uri" />
                <i:iterator name="run_of_service_property_uri" />
                <i:iterator name="run_of_process_property_uri" />
                <i:iterator name="process_service_relation_uri" />
                <i:iterator name="executed_process_instance_uri" />
                <i:iterator name="executed_service_instance_uri" />
                <i:iterator name="timestamp_shortstring" />
                <i:iterator name="datetime" />
                <i:iterator name="instance_ontology_url" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="append">no</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="instance_ontology_url" sink="InstantiateRunOfTextMiningProcessAndWorkflow:instance_ontology_url" />
        <s:link source="timestamp_iso8601" sink="InstantiateRunOfTextMiningProcessAndWorkflow:datetime" />
        <s:link source="timestamp_shortstring" sink="InstantiateRunOfTextMiningProcessAndWorkflow:timestamp_shortstring" />
        <s:link source="tmp_RDFdoc_fileref" sink="save_as:filename" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="Inst_081028_142923__Protoontology_AIDA_Instances__AIDA_ProteinTermColocationExtractionProcess:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:executed_process_instance_uri" />
        <s:link source="Inst_081028_142923__Protoontology_AIDA_Instances__BioAID_BioModellingSupportByProteinExtractionWorkflow:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:executed_service_instance_uri" />
        <s:link source="InstantiateRunOfTextMiningProcessAndWorkflow:NTriple_statements" sink="ConcatenateStringList:stringlist" />
        <s:link source="ObjProp_081028_171550__Protoontology_MappingBioTextMining__process_run_performed_by_computation_run:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:process_service_relation_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_TextMining__run_of_process:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:run_of_process_property_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_Workflow__computation_run_of:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:run_of_service_property_uri" />
        <s:link source="cls_081028_171550__Protoontology_TextMining__TextMiningProcessRun:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:process_run_type_uri" />
        <s:link source="cls_081028_171550__Protoontology_Workflow__ComputationRun:value" sink="InstantiateRunOfTextMiningProcessAndWorkflow:service_run_type_uri" />
        <s:link source="workflow_input" sink="InstantiateRunOfTextMiningProcessAndWorkflow:input" />
        <s:link source="InstantiateRunOfTextMiningProcessAndWorkflow:process_run_instance_uri" sink="AIDA_TextMiningProcessRun_instance" />
        <s:link source="InstantiateRunOfTextMiningProcessAndWorkflow:service_run_instance_uri" sink="AIDA_TextMiningWorkflowRun_instance" />
        <s:link source="save_as:save_asReturn" sink="workflow_rdf_doc_url" />
        <s:source name="instance_ontology_url" />
        <s:source name="tmp_RDFdoc_fileref" />
        <s:source name="timestamp_iso8601" />
        <s:source name="timestamp_shortstring" />
        <s:source name="workflow_input" />
        <s:sink name="workflow_rdf_doc_url" />
        <s:sink name="AIDA_TextMiningProcessRun_instance" />
        <s:sink name="AIDA_TextMiningWorkflowRun_instance" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="workflow_input" />
        <i:dot>
          <i:iterator name="timestamp_shortstring" />
          <i:iterator name="timestamp_iso8601" />
          <i:iterator name="tmp_RDFdoc_fileref" />
          <i:iterator name="instance_ontology_url" />
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="05_ScoreExtractedProteins">
    <s:description>This workflow calculates a min log likelihood score for the combination of a discoverd protein and a protein of interest (the query protein). Note that at the moment the total count of medline papers, which is part of the formula, is hard coded and not exact. Given its size this should not matter that much, and certainly not in comparison with other likelihoods calculated using the same value.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:abc3350b-e618-4fdd-8317-cbf5c298804d" author="Marco Roos (for AID)" title="LiteratureLikelihoodScoreProteinDiscoveryKnownQueryFreq">This workflow calculates a min log likelihood score for the combination of a discoverd protein and a protein of interest (the query protein). Note that at the moment the total count of medline papers, which is part of the formula, is hard coded and not exact. Given its size this should not matter much, and certainly not in comparison with other likelihoods calculated using the same value.

Computation:
-log likelihood ratio for finding query q and discovery d together computed by -log((QD_exp / N) / (QD_obs / N)), QD_exp = (Q/D)/N, where Q is the frequency of documents containing query q, D is the frequency of documents containing the discovery d, and QD the frequency of documents containing both q and d; QD_exp is the expected frequency of documents containing q and d assuming independence of q and d (H0). This score is a measure of 'specialness' of finding q and d together.</s:workflowdescription>
        <s:processor name="Ready" boring="true">
          <s:stringconstant>edit me!</s:stringconstant>
        </s:processor>
        <s:processor name="Flatten_discovered_frequency_list">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="Flatten_querydiscoveredfrequency">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="validate_query">
          <s:beanshell>
            <s:scriptvalue>int count_b = 0;
int count_q = 0;
int count_p = 0;
validated_query = query;

String s=query;
count_b = (s.length() - s.replaceAll("\\(", "").length());
count_b = count_b - (s.length() - s.replaceAll("\\)", "").length());

count_q = (s.length() - s.replaceAll("\"", "").length()) % 2;
count_p = (s.length() - s.replaceAll("'", "").length()) % 2;

count_brackets = count_p.toString();

while (count_b&gt;0) {
	validated_query = validated_query + ")";
	count_b--;
}

while (count_q != 0) {
	validated_query = validated_query + "\"";
	count_q--;
}

while (count_p != 0) {
	validated_query = validated_query + "'";
	count_p--;
}

while (count_p&lt;0) {
	validated_query = "'" + validated_query;
	count_p++;
}

validated_query = "(" + validated_query + ")" + " OR voetbalstadion";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">query</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">validated_query</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">count_brackets</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="CloneFrequencies">
          <s:beanshell>
            <s:scriptvalue>import java.util.*;

List newlist = new ArrayList();

for (int i=0; i&lt;((int) Integer.parseInt(copy_number.toString())); i++) {
	newlist.add(input);
}

clones=newlist;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">copy_number</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="l('text/plain')">clones</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="copy_number" />
              <i:iterator name="input" />
            </i:dot>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="Flatten_query_discovered_list">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="Flatten_query_frequency_list">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="MinLogLikelihood">
          <s:beanshell>
            <s:scriptvalue>/*
Mijn voorstel is een -log likelihood ratio:
-log ( (#QD_expected / #N) / (#QD / #N) )
waarbij
#QD : het gevonden aantal documenten met het Query eiwit Q, en het discovered eiwit D
#QD_expected = (#Q*#D)/#N : het verwachte aantal documenten met Q en D, gebaseerd op de gevonden aantallen #Q en #D

Edgar: De maat die je beschrijft lijkt erg veel op PMI (point-wise mutual information), wellicht dat je daar wat aan hebt. 
*/

/* variables
	query_frequency (#Q)
	discovered_frequency (#D)
	query_discovered_frequency (#QD)
	total_frequency (#N)
return
	minloglikelihood
*/
import java.lang.Math;
// import edu.uah.math.distributions;

Double mll;

if (query_discovered_frequency.equals("0")) {
	mll = (Double) Double.MAX_VALUE; // hack, have to find a more standard or sophisticated score
} else {
	double q = (double) Integer.parseInt( query_frequency );
	double d = (double) Integer.parseInt( discovered_frequency );
	double qd = (double) Integer.parseInt( query_discovered_frequency );
	double n = (double) Integer.parseInt( total_frequency );

	double qd_expected = (double) ((q*d)/n);

	mll = (Double) new Double((double) -( ((double) Math.log(qd_expected/n)) - ((double) Math.log(qd/n))));
}

minloglikelihood = mll.toString();

// minloglikelihood = (String) "test";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">query_frequency</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">discovered_frequency</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">query_discovered_frequency</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">total_frequency</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">minloglikelihood</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="total_frequency" />
              <i:dot>
                <i:iterator name="query_frequency" />
                <i:iterator name="query_discovered_frequency" />
                <i:iterator name="discovered_frequency" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="Flatten_mll">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="Flatten_discovery_list">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="CountListElements">
          <s:beanshell>
            <s:scriptvalue>count = list.size();</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/xml')">list</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">count</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="QueryDiscoveredFrequency">
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:abc3350b-e618-4fdd-8317-cbf5c298804d" author="" title="QueryFrequencyInCorpus" />
              <s:processor name="ExtractCountXpath" boring="true">
                <s:stringconstant>./aid:result/@total</s:stringconstant>
              </s:processor>
              <s:processor name="DocumentsIndex" boring="true">
                <s:stringconstant>MedLine</s:stringconstant>
              </s:processor>
              <s:processor name="Flatten_list">
                <s:local>
                  org.embl.ebi.escience.scuflworkers.java.FlattenList
                  <s:extensions>
                    <s:flattenlist s:depth="2" />
                  </s:extensions>
                </s:local>
              </s:processor>
              <s:processor name="XPath_From_Text">
                <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
              </s:processor>
              <s:processor name="PoiAndDpQuery">
                <s:beanshell>
                  <s:scriptvalue>poi_and_dp_query = "(" + poi_query + ") AND (" + dp_query + ")";</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">poi_query</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">dp_query</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">poi_and_dp_query</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="AIDA_search">
                <s:defaults>
                  <s:default name="maxHits">1</s:default>
                  <s:default name="defaultField">content</s:default>
                </s:defaults>
                <s:arbitrarywsdl>
                  <s:wsdl>http://aida.science.uva.nl:8888/axis/services/SearcherWS?wsdl</s:wsdl>
                  <s:operation>search</s:operation>
                </s:arbitrarywsdl>
              </s:processor>
              <s:link source="AIDA_search:searchReturn" sink="XPath_From_Text:xml-text" />
              <s:link source="DocumentsIndex:value" sink="AIDA_search:index" />
              <s:link source="ExtractCountXpath:value" sink="XPath_From_Text:xpath" />
              <s:link source="XPath_From_Text:nodelist" sink="Flatten_list:inputlist" />
              <s:link source="discovered_protein" sink="PoiAndDpQuery:dp_query" />
              <s:link source="query" sink="PoiAndDpQuery:poi_query" />
              <s:link source="Flatten_list:outputlist" sink="poidp_count_in_corpus" />
              <s:link source="PoiAndDpQuery:poi_and_dp_query" sink="AIDA_search:queryString" />
              <s:link source="PoiAndDpQuery:poi_and_dp_query" sink="poi_and_dp_query" />
              <s:source name="query" />
              <s:source name="discovered_protein" />
              <s:sink name="poidp_count_in_corpus" />
              <s:sink name="poi_and_dp_query" />
            </s:scufl>
          </s:workflow>
          <s:iterationstrategy>
            <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="query" />
              <i:iterator name="discovered_protein" />
            </i:dot>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="DiscoveredFrequency">
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:abc3350b-e618-4fdd-8317-cbf5c298804d" author="" title="QueryFrequencyInCorpus" />
              <s:processor name="ExtractCountXpath" boring="true">
                <s:stringconstant>./aid:result/@total</s:stringconstant>
              </s:processor>
              <s:processor name="DocumentsIndex" boring="true">
                <s:stringconstant>MedLine</s:stringconstant>
              </s:processor>
              <s:processor name="XPath_From_Text">
                <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
              </s:processor>
              <s:processor name="Flatten_list">
                <s:local>
                  org.embl.ebi.escience.scuflworkers.java.FlattenList
                  <s:extensions>
                    <s:flattenlist s:depth="2" />
                  </s:extensions>
                </s:local>
              </s:processor>
              <s:processor name="RelativeFrequencyPoiInCorpus">
                <s:defaults>
                  <s:default name="corpus_total">17000000</s:default>
                </s:defaults>
                <s:beanshell>
                  <s:scriptvalue>/* variables
	poi_count_in_corpus
	corpus_total
return
	relative_frequency
*/
import java.lang.Math;

Double rf = new Double(-Math.log((double)(Integer.parseInt( poi_count_in_corpus ) ) / ((double) (Integer.parseInt( corpus_total )))));

relative_frequency = rf.toString();</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">corpus_total</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">poi_count_in_corpus</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">relative_frequency</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="AIDA_search">
                <s:defaults>
                  <s:default name="maxHits">1</s:default>
                  <s:default name="defaultField">content</s:default>
                </s:defaults>
                <s:arbitrarywsdl maxretries="2" retrydelay="1000" critical="true">
                  <s:wsdl>http://aida.science.uva.nl:8888/axis/services/SearcherWS?wsdl</s:wsdl>
                  <s:operation>search</s:operation>
                </s:arbitrarywsdl>
              </s:processor>
              <s:link source="AIDA_search:searchReturn" sink="XPath_From_Text:xml-text" />
              <s:link source="ExtractCountXpath:value" sink="XPath_From_Text:xpath" />
              <s:link source="Flatten_list:outputlist" sink="RelativeFrequencyPoiInCorpus:poi_count_in_corpus" />
              <s:link source="XPath_From_Text:nodelist" sink="Flatten_list:inputlist" />
              <s:link source="corpus_total_doc_count" sink="RelativeFrequencyPoiInCorpus:corpus_total" />
              <s:link source="DocumentsIndex:value" sink="AIDA_search:index" />
              <s:link source="query" sink="AIDA_search:queryString" />
              <s:link source="Flatten_list:outputlist" sink="poi_count_in_corpus" />
              <s:link source="RelativeFrequencyPoiInCorpus:relative_frequency" sink="min_log_relative_frequency_poi_in_corpus" />
              <s:link source="query" sink="poi_query" />
              <s:source name="query" />
              <s:source name="corpus_total_doc_count" />
              <s:sink name="poi_count_in_corpus" />
              <s:sink name="min_log_relative_frequency_poi_in_corpus" />
              <s:sink name="poi_query" />
            </s:scufl>
          </s:workflow>
        </s:processor>
        <s:link source="DiscoveredFrequency:poi_count_in_corpus" sink="Flatten_discovered_frequency_list:inputlist" />
        <s:link source="DiscoveredFrequency:poi_query" sink="Flatten_discovery_list:inputlist" />
        <s:link source="Flatten_discovered_frequency_list:outputlist" sink="MinLogLikelihood:discovered_frequency" />
        <s:link source="Flatten_discovery_list:outputlist" sink="QueryDiscoveredFrequency:discovered_protein" />
        <s:link source="Flatten_query_discovered_list:outputlist" sink="MinLogLikelihood:query_discovered_frequency" />
        <s:link source="QueryDiscoveredFrequency:poidp_count_in_corpus" sink="Flatten_query_discovered_list:inputlist" />
        <s:link source="discovered_protein" sink="CountListElements:list" />
        <s:link source="CloneFrequencies:clones" sink="MinLogLikelihood:query_frequency" />
        <s:link source="CountListElements:count" sink="CloneFrequencies:copy_number" />
        <s:link source="Flatten_query_discovered_list:outputlist" sink="Flatten_querydiscoveredfrequency:inputlist" />
        <s:link source="Flatten_query_frequency_list:outputlist" sink="CloneFrequencies:input" />
        <s:link source="MinLogLikelihood:minloglikelihood" sink="Flatten_mll:inputlist" />
        <s:link source="PubMedTotalDocCount" sink="DiscoveredFrequency:corpus_total_doc_count" />
        <s:link source="PubMedTotalDocCount" sink="MinLogLikelihood:total_frequency" />
        <s:link source="discovered_protein" sink="validate_query:query" />
        <s:link source="query" sink="QueryDiscoveredFrequency:query" />
        <s:link source="query_frequency" sink="Flatten_query_frequency_list:inputlist" />
        <s:link source="Flatten_discovered_frequency_list:outputlist" sink="discovered_frequency" />
        <s:link source="Flatten_mll:outputlist" sink="min_log_likelihood" />
        <s:link source="Flatten_querydiscoveredfrequency:outputlist" sink="query_discovered_frequency" />
        <s:link source="validate_query:count_brackets" sink="test" />
        <s:link source="validate_query:validated_query" sink="DiscoveredFrequency:query" />
        <s:source name="query">
          <s:metadata>
            <s:description>E.g. EZH2</s:description>
          </s:metadata>
        </s:source>
        <s:source name="discovered_protein">
          <s:metadata>
            <s:description>E.g. HDAC1</s:description>
          </s:metadata>
        </s:source>
        <s:source name="query_frequency" />
        <s:source name="PubMedTotalDocCount" />
        <s:sink name="discovered_frequency" />
        <s:sink name="min_log_likelihood" />
        <s:sink name="query_discovered_frequency" />
        <s:sink name="test" />
        <s:coordination name="Ready_BLOCKON_MinLogLikelihood">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>MinLogLikelihood</s:target>
          </s:condition>
          <s:action>
            <s:target>Ready</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:dot>
          <i:iterator name="query" />
          <i:iterator name="query_frequency" />
          <i:iterator name="PubMedTotalDocCount" />
        </i:dot>
        <i:iterator name="discovered_protein" />
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="s08_AddRdfToRepository">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:da1b0987-a2aa-432d-b481-7f8410578a84" author="" title="AddRdfFileToRepository" />
        <s:processor name="Fail_if_true_Prevent_add">
          <s:defaults>
            <s:default name="test">true</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
        </s:processor>
        <s:processor name="password_bioaid">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>password_bioaid</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="aida_semantic_server_url">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>aida_semantic_server_url</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="repository_bioaid">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>repository_bioaid</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="username_bioaid">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>username_bioaid</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="addRdfFile">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/services/RepositoryWS?wsdl</s:wsdl>
            <s:operation>addRdfFile</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="aida_magic_word" sink="password_bioaid:magic_word" />
        <s:link source="aida_magic_word" sink="username_bioaid:magic_word" />
        <s:link source="aida_semantic_server_url:aida_semantic_server_urlReturn" sink="addRdfFile:server_url" />
        <s:link source="do_not_add_to_repository" sink="Fail_if_true_Prevent_add:test" />
        <s:link source="password_bioaid:password_bioaidReturn" sink="addRdfFile:password" />
        <s:link source="rdfFile_url" sink="addRdfFile:data_uri" />
        <s:link source="rdf_format" sink="addRdfFile:rdf_format" />
        <s:link source="repository_bioaid:repository_bioaidReturn" sink="addRdfFile:repository" />
        <s:link source="username_bioaid:username_bioaidReturn" sink="addRdfFile:username" />
        <s:source name="rdfFile_url">
          <s:metadata>
            <s:description>e.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:source name="aida_magic_word" />
        <s:source name="rdf_format" />
        <s:source name="do_not_add_to_repository">
          <s:metadata>
            <s:description>true to prevent adding  rdf statements to the repository</s:description>
          </s:metadata>
        </s:source>
        <s:coordination name="addRdfFile_BLOCKON_Fail_if_true_Prevent_add">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>Fail_if_true_Prevent_add</s:target>
          </s:condition>
          <s:action>
            <s:target>addRdfFile</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="01b_CalculateQueryFrequency">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:abc3350b-e618-4fdd-8317-cbf5c298804d" author="" title="QueryFrequencyInCorpus" />
        <s:processor name="DocumentsIndex" boring="true">
          <s:stringconstant>MedLine</s:stringconstant>
        </s:processor>
        <s:processor name="ExtractCountXpath" boring="true">
          <s:stringconstant>./aid:result/@total</s:stringconstant>
        </s:processor>
        <s:processor name="Flatten_list">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="XPath_From_Text">
          <s:local>net.sourceforge.taverna.scuflworkers.xml.XPathTextWorker</s:local>
        </s:processor>
        <s:processor name="RelativeFrequencyPoiInCorpus">
          <s:defaults>
            <s:default name="corpus_total">17000000</s:default>
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* variables
	poi_count_in_corpus
	corpus_total
return
	relative_frequency
*/
import java.lang.Math;

Double rf = new Double(-Math.log((double)(Integer.parseInt( poi_count_in_corpus ) ) / ((double) (Integer.parseInt( corpus_total )))));

relative_frequency = rf.toString();</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">corpus_total</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">poi_count_in_corpus</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">relative_frequency</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="AIDA_search">
          <s:defaults>
            <s:default name="maxHits">1</s:default>
            <s:default name="defaultField">content</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:9999/axis/services/SearcherWS?wsdl</s:wsdl>
            <s:operation>search</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="AIDA_search:searchReturn" sink="XPath_From_Text:xml-text" />
        <s:link source="ExtractCountXpath:value" sink="XPath_From_Text:xpath" />
        <s:link source="Flatten_list:outputlist" sink="RelativeFrequencyPoiInCorpus:poi_count_in_corpus" />
        <s:link source="XPath_From_Text:nodelist" sink="Flatten_list:inputlist" />
        <s:link source="corpus_total_doc_count" sink="RelativeFrequencyPoiInCorpus:corpus_total" />
        <s:link source="DocumentsIndex:value" sink="AIDA_search:index" />
        <s:link source="query" sink="AIDA_search:queryString" />
        <s:link source="Flatten_list:outputlist" sink="poi_count_in_corpus" />
        <s:link source="RelativeFrequencyPoiInCorpus:relative_frequency" sink="min_log_relative_frequency_poi_in_corpus" />
        <s:link source="query" sink="poi_query" />
        <s:source name="query" />
        <s:source name="corpus_total_doc_count" />
        <s:sink name="poi_count_in_corpus" />
        <s:sink name="min_log_relative_frequency_poi_in_corpus" />
        <s:sink name="poi_query" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="s01_AddBiologicalModelToSemanticModel">
    <s:description>Add Query to Semantic model with Sesame service cf example Biological Query</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:2ca45a93-0d4d-4e5c-b305-240df4ae1d18" author="Marco Roos (workflow), Willem R. van Hage (service)" title="InstantiateBiologicalModel">Add Query to Semantic model with Sesame service cf example Biological Query</s:workflowdescription>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="Class_080813_112057__Protoontology_BioModel__BiologicalModel" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#BiologicalModel</s:stringconstant>
        </s:processor>
        <s:processor name="InstantiateSemanticType">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string

output:
NTriple_InstanceOf_statement
instance_uri
*/

instance_uri = instance_ontology_url + "#" + instance_name;

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ParseToBioModelID">
          <s:beanshell>
            <s:scriptvalue>/*
replace characters that Protégé does not like for names
*/

import java.util.regex.*;
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

String tmpstring = input;
/*
Pattern p = Pattern.compile("#");
Matcher m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;hash;");

p = Pattern.compile("\\^");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;caret;");

p = Pattern.compile("&lt;");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;lt;");

p = Pattern.compile("&gt;");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;gt;");

p = Pattern.compile("\\{");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;lcurly;");

p = Pattern.compile("\\}");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;rcurly;");

p = Pattern.compile("%");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;perc;");

p = Pattern.compile("_");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;ndash;");

p = Pattern.compile("\"");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("&amp;quot;");

p = Pattern.compile("\\s");
m = p.matcher(tmpstring);
tmpstring = (String) m.replaceAll("_");
*/

tmpstring = "BioModel_" + URLEncoder.encode(tmpstring, "UTF-8");

output = tmpstring;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="append">no</s:default>
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="BioModelComment" sink="InstantiateSemanticType:comment_string" />
        <s:link source="InstanceOntologyURL" sink="InstantiateSemanticType:instance_ontology_url" />
        <s:link source="ModelIdentifyingName" sink="ParseToBioModelID:input" />
        <s:link source="RDF_doc_filename" sink="save_as:filename" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="Class_080813_112057__Protoontology_BioModel__BiologicalModel:value" sink="InstantiateSemanticType:type_uri" />
        <s:link source="InstantiateSemanticType:NTriple_InstanceOf_statement" sink="save_as:content" />
        <s:link source="ParseToBioModelID:output" sink="InstantiateSemanticType:instance_name" />
        <s:link source="InstantiateSemanticType:instance_uri" sink="biomodel_instance_uri" />
        <s:link source="save_as:save_asReturn" sink="QueryRDFdoc_url" />
        <s:source name="ModelIdentifyingName">
          <s:metadata>
            <s:description>Unique name to identify the Biological model by. This name is used as the unique identifier for the model. Characters that cannot be used by OWL in a name are replaced.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="RDF_doc_filename">
          <s:metadata>
            <s:description>Reference to  file for RDF output.

E.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:source name="InstanceOntologyURL">
          <s:metadata>
            <s:description>Instance ontology URL. E.g. http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:description>
          </s:metadata>
        </s:source>
        <s:source name="BioModelComment" />
        <s:sink name="biomodel_instance_uri" />
        <s:sink name="QueryRDFdoc_url" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="s00_InitializeSemanticStorage">
    <s:defaults>
      <s:default name="do_not_clear_repository">false</s:default>
      <s:default name="do_not_add_to_repository">false</s:default>
      <s:default name="do_not_clear_tmp_rdf_file">false</s:default>
    </s:defaults>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:4426fbe2-64df-43c2-8005-bc49d575508d" author="" title="Reload_BioAID_ProteinDiscovery_Ontologies" />
        <s:processor name="Workflow_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl</s:stringconstant>
        </s:processor>
        <s:processor name="TextMining_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl</s:stringconstant>
        </s:processor>
        <s:processor name="BioAnnotations_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioAnnotations.owl</s:stringconstant>
        </s:processor>
        <s:processor name="AIDA_Instances_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/AIDA_Instances.owl</s:stringconstant>
        </s:processor>
        <s:processor name="Append_no" boring="true">
          <s:stringconstant>no</s:stringconstant>
        </s:processor>
        <s:processor name="rdf_Ntriple_format" boring="true">
          <s:description>'rdfxml' or 'turtle' or 'n3'</s:description>
          <s:stringconstant>n3</s:stringconstant>
        </s:processor>
        <s:processor name="Mapping_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl</s:stringconstant>
        </s:processor>
        <s:processor name="rdf_format" boring="true">
          <s:stringconstant>rdfxml</s:stringconstant>
        </s:processor>
        <s:processor name="BioAIDinstances_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:stringconstant>
        </s:processor>
        <s:processor name="BioModel_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl</s:stringconstant>
        </s:processor>
        <s:processor name="Text_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Text.owl</s:stringconstant>
        </s:processor>
        <s:processor name="ExampleInstances_ontology_url" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl</s:stringconstant>
        </s:processor>
        <s:processor name="Fail_if_true_Prevent_add">
          <s:defaults>
            <s:default name="test">false</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
        </s:processor>
        <s:processor name="Fail_if_true_Prevent_clear">
          <s:defaults>
            <s:default name="test">false</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
        </s:processor>
        <s:processor name="RepositoryRef">
          <s:beanshell>
            <s:scriptvalue>bioaid_repository_url = sesame_url.substring(0,sesame_url.length()-6) + "workbench/repositories/" + repository;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">sesame_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">repository</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">bioaid_repository_url</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="AddQueryToFilename">
          <s:beanshell>
            <s:scriptvalue>/*
replace characters that Protégé does not like for names
*/

import java.util.regex.*;
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

new_filename = input_filename.substring(0, input_filename.length()-4) + URLEncoder.encode(input_query, "UTF-8") + input_filename.substring(input_filename.length()-4);</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">input_query</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">input_filename</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">new_filename</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="Fail_if_true_Prevent_init">
          <s:local>org.embl.ebi.escience.scuflworkers.java.FailIfTrue</s:local>
        </s:processor>
        <s:processor name="save_as">
          <s:defaults>
            <s:default name="content" />
          </s:defaults>
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="def_rdf_output_doc_url_ts">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>def_rdf_output_doc_url_ts</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="password_bioaid_sandbox">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>password_bioaid_sandbox</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="aida_semantic_sandbox_server_url">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>aida_semantic_sandbox_server_url</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="addRdfFile">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/services/RepositoryWS?wsdl</s:wsdl>
            <s:operation>addRdfFile</s:operation>
          </s:arbitrarywsdl>
          <s:mergemode input="data_uri" mode="merge" />
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="data_uri" />
              <i:dot>
                <i:iterator name="rdf_format" />
                <i:iterator name="password" />
                <i:iterator name="username" />
                <i:iterator name="repository" />
                <i:iterator name="server_url" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="username_bioaid_sandbox">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>username_bioaid_sandbox</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="repository_bioaid_sandbox">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaSemanticStorage.jws?wsdl</s:wsdl>
            <s:operation>repository_bioaid_sandbox</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:processor name="clear">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/services/RepositoryWS?wsdl</s:wsdl>
            <s:operation>clear</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="AIDA_Instances_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="AddQueryToFilename:new_filename" sink="save_as:filename" />
        <s:link source="Append_no:value" sink="save_as:append" />
        <s:link source="BioAIDinstances_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="BioAnnotations_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="BioModel_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="ExampleInstances_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="Mapping_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="TextMining_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="Text_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="Workflow_ontology_url:value" sink="addRdfFile:data_uri" />
        <s:link source="aida_magic_word" sink="password_bioaid_sandbox:magic_word" />
        <s:link source="aida_magic_word" sink="repository_bioaid_sandbox:magic_word" />
        <s:link source="aida_magic_word" sink="username_bioaid_sandbox:magic_word" />
        <s:link source="do_not_add_to_repository" sink="Fail_if_true_Prevent_add:test" />
        <s:link source="do_not_clear_repository" sink="Fail_if_true_Prevent_clear:test" />
        <s:link source="do_not_clear_tmp_rdf_file" sink="Fail_if_true_Prevent_init:test" />
        <s:link source="aida_semantic_sandbox_server_url:aida_semantic_sandbox_server_urlReturn" sink="RepositoryRef:sesame_url" />
        <s:link source="aida_semantic_sandbox_server_url:aida_semantic_sandbox_server_urlReturn" sink="addRdfFile:server_url" />
        <s:link source="aida_semantic_sandbox_server_url:aida_semantic_sandbox_server_urlReturn" sink="clear:server_url" />
        <s:link source="original_input_query" sink="AddQueryToFilename:input_query" />
        <s:link source="def_rdf_output_doc_url_ts:def_rdf_output_doc_url_tsReturn" sink="AddQueryToFilename:input_filename" />
        <s:link source="password_bioaid_sandbox:password_bioaid_sandboxReturn" sink="addRdfFile:password" />
        <s:link source="password_bioaid_sandbox:password_bioaid_sandboxReturn" sink="clear:password" />
        <s:link source="AIDA_Instances_ontology_url:value" sink="AIDA_Instances_ontology_url" />
        <s:link source="AddQueryToFilename:new_filename" sink="RDFoutput_doc_url" />
        <s:link source="BioAIDinstances_ontology_url:value" sink="BioAIDinstances_ontology_url" />
        <s:link source="BioAnnotations_ontology_url:value" sink="BioAnnotations_ontology_url" />
        <s:link source="BioModel_ontology_url:value" sink="BioModel_ontology_url" />
        <s:link source="ExampleInstances_ontology_url:value" sink="ExampleInstances_ontology_url" />
        <s:link source="rdf_format:value" sink="addRdfFile:rdf_format" />
        <s:link source="repository_bioaid_sandbox:repository_bioaid_sandboxReturn" sink="RepositoryRef:repository" />
        <s:link source="repository_bioaid_sandbox:repository_bioaid_sandboxReturn" sink="addRdfFile:repository" />
        <s:link source="repository_bioaid_sandbox:repository_bioaid_sandboxReturn" sink="clear:repository" />
        <s:link source="username_bioaid_sandbox:username_bioaid_sandboxReturn" sink="addRdfFile:username" />
        <s:link source="username_bioaid_sandbox:username_bioaid_sandboxReturn" sink="clear:username" />
        <s:link source="Mapping_ontology_url:value" sink="Mapping_ontology_url" />
        <s:link source="RepositoryRef:bioaid_repository_url" sink="BioAID_Repository_url" />
        <s:link source="TextMining_ontology_url:value" sink="TextMining_ontology_url" />
        <s:link source="Text_ontology_url:value" sink="Text_ontology_url" />
        <s:link source="Workflow_ontology_url:value" sink="Workflow_ontology_url" />
        <s:link source="rdf_Ntriple_format:value" sink="Rdf_NTriple_format" />
        <s:source name="aida_magic_word" />
        <s:source name="do_not_clear_repository">
          <s:metadata>
            <s:description>true to prevent the repository from being cleared before adding semantic models</s:description>
          </s:metadata>
        </s:source>
        <s:source name="do_not_add_to_repository">
          <s:metadata>
            <s:description>true to prevent adding the ontologies to the repository</s:description>
          </s:metadata>
        </s:source>
        <s:source name="do_not_clear_tmp_rdf_file">
          <s:metadata>
            <s:description>true to prevent the temporary rdf output file for intermediate rdf output to be overwritten with an empty document.</s:description>
          </s:metadata>
        </s:source>
        <s:source name="original_input_query" />
        <s:sink name="BioAID_Repository_url" />
        <s:sink name="Workflow_ontology_url" />
        <s:sink name="BioAIDinstances_ontology_url" />
        <s:sink name="Text_ontology_url" />
        <s:sink name="BioModel_ontology_url" />
        <s:sink name="TextMining_ontology_url" />
        <s:sink name="Mapping_ontology_url" />
        <s:sink name="BioAnnotations_ontology_url" />
        <s:sink name="ExampleInstances_ontology_url" />
        <s:sink name="Rdf_NTriple_format" />
        <s:sink name="RDFoutput_doc_url" />
        <s:sink name="AIDA_Instances_ontology_url" />
        <s:coordination name="addRdfFile_BLOCKON_clear">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>clear</s:target>
          </s:condition>
          <s:action>
            <s:target>addRdfFile</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
        <s:coordination name="clear_BLOCKON_Fail_if_true">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>Fail_if_true_Prevent_clear</s:target>
          </s:condition>
          <s:action>
            <s:target>clear</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
        <s:coordination name="addRdfFile_BLOCKON_Fail_if_true_Precent_add">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>Fail_if_true_Prevent_add</s:target>
          </s:condition>
          <s:action>
            <s:target>addRdfFile</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
        <s:coordination name="save_as_BLOCKON_Fail_if_true_Prevent_init">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>Fail_if_true_Prevent_init</s:target>
          </s:condition>
          <s:action>
            <s:target>save_as</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="06_UniProtXrefURLs_iHopBYPASS">
    <s:description>Adds URL cross references to various protein information resources.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:c0a963bc-2343-4d31-aa8c-304bfe3a6289" author="Marco Roos (workflow)" title="XrefsForUniProt">Adds URL cross references to various protein information resources.</s:workflowdescription>
        <s:processor name="UniProtURL_stub" boring="true">
          <s:stringconstant>http://www.uniprot.org/uniprot/</s:stringconstant>
        </s:processor>
        <s:processor name="iHopSentenceURL_prestub" boring="true">
          <s:stringconstant>http://www.ihop-net.org/UniPub/iHOP/gismo/</s:stringconstant>
        </s:processor>
        <s:processor name="iHopSentenceURL_poststub" boring="true">
          <s:stringconstant>.html?ORGANISM_ID=1</s:stringconstant>
        </s:processor>
        <s:processor name="UniProtRDF_poststub" boring="true">
          <s:stringconstant>.rdf</s:stringconstant>
        </s:processor>
        <s:processor name="ExpasyUniProtURL_stub" boring="true">
          <s:stringconstant>http://expasy.org/uniprot/</s:stringconstant>
        </s:processor>
        <s:processor name="EntrezPubMedUniProtURL_stub" boring="true">
          <s:stringconstant>http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&amp;val=</s:stringconstant>
        </s:processor>
        <s:processor name="iHopSearchURL_stub" boring="true">
          <s:stringconstant>http://www.ihop-net.org/UniPub/iHOP/?field=UNIPROT__AC&amp;ncbi_tax_id=9606&amp;organism_syn=&amp;search=</s:stringconstant>
        </s:processor>
        <s:processor name="iHOP_BYPASS_STRING" boring="true">
          <s:stringconstant>http://www.ihop-net.org/UniPub/iHOP/gismo/SKIPPED.html?ORGANISM_ID=1</s:stringconstant>
        </s:processor>
        <s:processor name="RemoveToUndoBYPASS">
          <s:defaults>
            <s:default name="foo">foo</s:default>
            <s:default name="bar">bar</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.TestAlwaysFailingProcessor</s:local>
        </s:processor>
        <s:processor name="Concatenate_iHopURL_preStub">
          <s:defaults>
            <s:default name="string1">http&amp;#58;//www.ihop-net.org/UniPub/iHOP/gismo/</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="Concatenate_UniProt_RDF">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="Concatenate_UniProtURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="ExtractiHopRefByRegexp">
          <s:defaults>
            <s:default name="regex">&lt;iHOPguessedSymbolId query=\".+\" xmlns=\"http://www.pdg.cnb.uam.es/UniPub/iHOP/xml\"&gt;(.+)&lt;/iHOPguessedSymbolId&gt;</s:default>
            <s:default name="group">1</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.RegularExpressionStringList</s:local>
        </s:processor>
        <s:processor name="Concatenate_iHopURL_postStub">
          <s:defaults>
            <s:default name="string2">.html?ORGANISM_ID=1</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="ConcatenateExpasyURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="ConcatenateEntrezURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="Concatenate_iHopURL">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="guessSymbolIdFromReference">
          <s:description>It takes a biological database reference as input. It guess the iHOP Id which best matches with the input.</s:description>
          <s:arbitrarywsdl>
            <s:wsdl>http://ubio.bioinfo.cnio.es/biotools/iHOP/iHOP-SOAP.wsdl</s:wsdl>
            <s:operation>guessSymbolIdFromReference</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="UniProtID" sink="ConcatenateEntrezURL:string2" />
        <s:link source="UniProtID" sink="ConcatenateExpasyURL:string2" />
        <s:link source="UniProtID" sink="Concatenate_UniProtURL:string2" />
        <s:link source="UniProtID" sink="Concatenate_iHopURL:string2" />
        <s:link source="UniProtID" sink="guessSymbolIdFromReference:reference" />
        <s:link source="ConcatenateEntrezURL:output" sink="EntrezUniProtURL" />
        <s:link source="ConcatenateExpasyURL:output" sink="ExpasyUniProtURL" />
        <s:link source="Concatenate_UniProtURL:output" sink="Concatenate_UniProt_RDF:string1" />
        <s:link source="Concatenate_UniProtURL:output" sink="UniProtURL" />
        <s:link source="Concatenate_UniProt_RDF:output" sink="UniProtID_RDF" />
        <s:link source="Concatenate_iHopURL_preStub:output" sink="Concatenate_iHopURL_postStub:string1" />
        <s:link source="EntrezPubMedUniProtURL_stub:value" sink="ConcatenateEntrezURL:string1" />
        <s:link source="ExpasyUniProtURL_stub:value" sink="ConcatenateExpasyURL:string1" />
        <s:link source="ExtractiHopRefByRegexp:filteredlist" sink="Concatenate_iHopURL_preStub:string2" />
        <s:link source="UniProtRDF_poststub:value" sink="Concatenate_UniProt_RDF:string2" />
        <s:link source="UniProtURL_stub:value" sink="Concatenate_UniProtURL:string1" />
        <s:link source="guessSymbolIdFromReference:result" sink="ExtractiHopRefByRegexp:stringlist" />
        <s:link source="iHopSearchURL_stub:value" sink="Concatenate_iHopURL:string1" />
        <s:link source="iHopSentenceURL_poststub:value" sink="Concatenate_iHopURL_postStub:string2" />
        <s:link source="iHopSentenceURL_prestub:value" sink="Concatenate_iHopURL_preStub:string1" />
        <s:link source="Concatenate_iHopURL:output" sink="iHopSearchURL" />
        <s:link source="Concatenate_iHopURL_postStub:output" sink="relink_to_iHopSentencesURL_to_undo_bypass" />
        <s:link source="iHOP_BYPASS_STRING:value" sink="iHopSentencesURL" />
        <s:source name="UniProtID">
          <s:metadata>
            <s:description>UniProt ID (for iHop a Human protein is expected)
E.g. Q15190</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="ExpasyUniProtURL" />
        <s:sink name="EntrezUniProtURL" />
        <s:sink name="iHopSearchURL">
          <s:metadata>
            <s:mimeTypes>
              <s:mimeType>text/xml</s:mimeType>
            </s:mimeTypes>
          </s:metadata>
        </s:sink>
        <s:sink name="iHopSentencesURL" />
        <s:sink name="UniProtID_RDF" />
        <s:sink name="UniProtURL" />
        <s:sink name="relink_to_iHopSentencesURL_to_undo_bypass" />
        <s:coordination name="guessSymbolIdFromReference_BLOCKON_TEST___always_fails">
          <s:condition>
            <s:state>Completed</s:state>
            <s:target>RemoveToUndoBYPASS</s:target>
          </s:condition>
          <s:action>
            <s:target>guessSymbolIdFromReference</s:target>
            <s:statechange>
              <s:from>Scheduled</s:from>
              <s:to>Running</s:to>
            </s:statechange>
          </s:action>
        </s:coordination>
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="04_ExtractProteinRelations_HomoSapiens">
    <s:description>Workflow to extract protein protein interactions from text, followed by filtering protein names known as human protein names. The protein protein interaction service takes the output in 'IOB' format from applyCRF, which annotates proteins as such in text.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:c0a963bc-2343-4d31-aa8c-304bfe3a6289" author="Marco Roos (workflow), Sophia Katrenko (extraction service), Martijn Schuemie (validation service)" title="ExtractProteinProteinInteractionsFromText_HomoSapiens">[Work in progress and temporarily out of service]

Workflow to extract protein protein interactions from text, followed by filtering protein names known as human protein names. The protein protein interaction service takes the output in 'IOB' format from applyCRF, which annotates proteins as such in text.

ToDo:
Add Relation extraction subworkflow for real.</s:workflowdescription>
        <s:processor name="split_interaction_regexp" boring="true">
          <s:stringconstant>(.+)\s+(.+)</s:stringconstant>
        </s:processor>
        <s:processor name="IOB_output_from_NER_example" boring="true">
          <s:stringconstant>We	O have	O identified	O a	O transcriptional	O repressor,	O Nrg1,	O in	O a	O genetic	O screen	O designed	O to	O reveal	O negative	O factors	O involved	O in	O the	O expression	O of	O STA1,	B-PROTEIN which	O encodes	O a	O glucoamylase.	O The	O NRG1	B-PROTEIN gene	I-PROTEIN encodes	O a	O 25-kDa	O C2H2	B-PROTEIN zinc	I-PROTEIN finger	I-PROTEIN protein	I-PROTEIN which	O specifically	O binds	O to	O two	O regions	O in	O the	O upstream	O activation	O sequence	O of	O the	O STA1	B-PROTEIN gene,	O as	O judged	O by	O gel	O retardation	O and	O DNase	B-PROTEIN I	I-PROTEIN footprinting	O analyses.	O Disruption	O of	O the	O NRG1	B-PROTEIN gene	I-PROTEIN causes	O a	O fivefold	O increase	O in	O the	O level	O of	O the	O STA1	B-PROTEIN transcript	O in	O the	O presence	O of	O glucose.	O</s:stringconstant>
        </s:processor>
        <s:processor name="Filter_protein1">
          <s:defaults>
            <s:default name="group">1</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.RegularExpressionStringList</s:local>
        </s:processor>
        <s:processor name="Filter_protein2">
          <s:defaults>
            <s:default name="group">2</s:default>
          </s:defaults>
          <s:local>org.embl.ebi.escience.scuflworkers.java.RegularExpressionStringList</s:local>
        </s:processor>
        <s:processor name="split_interactionlist">
          <s:local>org.embl.ebi.escience.scuflworkers.java.SplitByRegex</s:local>
        </s:processor>
        <s:processor name="FlattenUniprotlist1">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="FlattenProteinlist1">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="FlattenProteinlist2">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="FlattenUniProtlist2">
          <s:local>
            org.embl.ebi.escience.scuflworkers.java.FlattenList
            <s:extensions>
              <s:flattenlist s:depth="2" />
            </s:extensions>
          </s:local>
        </s:processor>
        <s:processor name="example_interaction_doc">
          <s:beanshell>
            <s:scriptvalue>interaction_doc = "P300 TP53\r\nIRF3 CITED1\r\nCITED1 STAT5A\r\nTP73 P300\r\nP300 ZAC1\r\nP300 mSRC-1\r\nSigK T4\r\nGerE ykvP\r\nSpoIIE sigma(F)\r\nrsfA sigma(F)\r\nsigma(K) cwlH\r\nsigma(K) gerE\r\ncwlH gerE\r\nphrC sigmaH\r\nphrC CSF\r\nsigmaH CSF\r\nyfhS E_sigma_E\r\nsigmaK Spo0A\r\nsigmaK sigE\r\nSpo0A sigE\r\nGerE sigK\r\nGerE sigmaK\r\nsigK sigmaK\r\nsigmaK gerE\r\nsigmaK GerE\r\nsigmaK sigmaK\r\ngerE GerE\r\ngerE sigmaK\r\nGerE sigmaK\r\nGerE cotD\r\nGerE sigmaK\r\nGerE GerE\r\nGerE cotD\r\ncotD sigmaK\r\ncotD GerE\r\ncotD cotD\r\nsigmaK GerE\r\nsigmaK cotD\r\nGerE cotD\r\n";</s:scriptvalue>
            <s:beanshellinputlist />
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">interaction_doc</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ConcatenateRelation">
          <s:defaults>
            <s:default name="interaction_term">unspecified relation</s:default>
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>relation = protein_name1 + " - " + interaction_term + " - " + protein_name2;
id_relation = uniprot_id1 + ", " + interaction_term + ", " + uniprot_id2;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">protein_name1</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">protein_name2</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">interaction_term</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">uniprot_id1</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">uniprot_id2</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">relation</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">id_relation</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="uniprot_id2" />
              <i:iterator name="uniprot_id1" />
              <i:iterator name="protein_name2" />
              <i:iterator name="protein_name1" />
            </i:dot>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="split_interactions_regexp" boring="true">
          <s:stringconstant>(\r\n)|(\n)</s:stringconstant>
        </s:processor>
        <s:processor name="FilterHumanProteinPairs">
          <s:description>This workflow filters protein_molecule-labeled term pairs from two input strings(list). The result is a pair of tagged lists of proteins. It uses a UniProt service by Martijn Schuemie (BioSemantics group Rotterdam) that know about human proteins.</s:description>
          <s:workflow retrydelay="10" retrybackoff="10.0">
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:df6063f9-b469-4d56-aecc-a62db4bcb3ad" author="Marco Roos (AID)" title="FilterHumanProteinsPairsByUniprot">This workflow filters protein_molecule-labeled terms from an input string(list). The result is a tagged list of proteins (disregarding false positives in the input).

Internal information:
This workflow is a copy of 'filter_protein_molecule_MR3' used for the NBIC poster (now in Archive).</s:workflowdescription>
              <s:processor name="filter_regexp" boring="true">
                <s:stringconstant>.+</s:stringconstant>
              </s:processor>
              <s:processor name="FilterTrueProteinPairsByUniProtID">
                <s:beanshell>
                  <s:scriptvalue>if (uniprot1 != "False" &amp;&amp; uniprot2 != "False") {
	true_protein1=protein1;
	true_uniprot1=uniprot1;
	true_protein2=protein2;
	true_uniprot2=uniprot2;
}</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">protein1</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">uniprot1</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">protein2</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">uniprot2</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">true_protein1</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="'text/plain'">true_uniprot1</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="'text/plain'">true_protein2</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="'text/plain'">true_uniprot2</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
                <s:iterationstrategy>
                  <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
                    <i:iterator name="uniprot2" />
                    <i:iterator name="protein2" />
                    <i:iterator name="uniprot1" />
                    <i:iterator name="protein1" />
                  </i:dot>
                </s:iterationstrategy>
              </s:processor>
              <s:processor name="Filter_uniprot1">
                <s:defaults>
                  <s:default name="regex">.+</s:default>
                </s:defaults>
                <s:local>org.embl.ebi.escience.scuflworkers.java.FilterStringList</s:local>
              </s:processor>
              <s:processor name="UniProtOrNot2">
                <s:beanshell>
                  <s:scriptvalue>if (uniprotIDlist.isEmpty() ) {
	uniprotID_or_False = "False";
} else {
	uniprotID_or_False = (String) uniprotIDlist.iterator().next().toString();
}</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">uniprotIDlist</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">uniprotID_or_False</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="Filter_uniprot2">
                <s:local>org.embl.ebi.escience.scuflworkers.java.FilterStringList</s:local>
              </s:processor>
              <s:processor name="Filter_protein1">
                <s:defaults>
                  <s:default name="regex">.+</s:default>
                </s:defaults>
                <s:local>org.embl.ebi.escience.scuflworkers.java.FilterStringList</s:local>
              </s:processor>
              <s:processor name="Filter_protein2">
                <s:local>org.embl.ebi.escience.scuflworkers.java.FilterStringList</s:local>
              </s:processor>
              <s:processor name="UniProtOrNot1">
                <s:beanshell>
                  <s:scriptvalue>if (uniprotIDlist.isEmpty() ) {
	uniprotID_or_False = "False";
} else {
	uniprotID_or_False = (String) uniprotIDlist.iterator().next().toString();
}</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">uniprotIDlist</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">uniprotID_or_False</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="getUniprotID1">
                <s:arbitrarywsdl retrydelay="1">
                  <s:wsdl>http://biosemantics.org:8080/axis/services/SynsetServer/SynsetServer.jws?wsdl</s:wsdl>
                  <s:operation>getUniprotID</s:operation>
                </s:arbitrarywsdl>
              </s:processor>
              <s:processor name="getUniprotID2">
                <s:arbitrarywsdl>
                  <s:wsdl>http://biosemantics.org:8080/axis/services/SynsetServer/SynsetServer.jws?wsdl</s:wsdl>
                  <s:operation>getUniprotID</s:operation>
                </s:arbitrarywsdl>
              </s:processor>
              <s:link source="candidate1" sink="getUniprotID1:term" />
              <s:link source="candidate2" sink="getUniprotID2:term" />
              <s:link source="UniProtOrNot1:uniprotID_or_False" sink="FilterTrueProteinPairsByUniProtID:uniprot1" />
              <s:link source="UniProtOrNot2:uniprotID_or_False" sink="FilterTrueProteinPairsByUniProtID:uniprot2" />
              <s:link source="candidate1" sink="FilterTrueProteinPairsByUniProtID:protein1" />
              <s:link source="candidate2" sink="FilterTrueProteinPairsByUniProtID:protein2" />
              <s:link source="FilterTrueProteinPairsByUniProtID:true_protein1" sink="Filter_protein1:stringlist" />
              <s:link source="FilterTrueProteinPairsByUniProtID:true_protein2" sink="Filter_protein2:stringlist" />
              <s:link source="FilterTrueProteinPairsByUniProtID:true_uniprot1" sink="Filter_uniprot1:stringlist" />
              <s:link source="FilterTrueProteinPairsByUniProtID:true_uniprot2" sink="Filter_uniprot2:stringlist" />
              <s:link source="Filter_protein1:filteredlist" sink="protein_molecule1" />
              <s:link source="Filter_uniprot1:filteredlist" sink="uniprotID1" />
              <s:link source="filter_regexp:value" sink="Filter_protein1:regex" />
              <s:link source="filter_regexp:value" sink="Filter_protein2:regex" />
              <s:link source="filter_regexp:value" sink="Filter_uniprot1:regex" />
              <s:link source="filter_regexp:value" sink="Filter_uniprot2:regex" />
              <s:link source="getUniprotID1:getUniprotIDReturn" sink="UniProtOrNot1:uniprotIDlist" />
              <s:link source="getUniprotID2:getUniprotIDReturn" sink="UniProtOrNot2:uniprotIDlist" />
              <s:link source="Filter_protein2:filteredlist" sink="protein_molecule2" />
              <s:link source="Filter_uniprot2:filteredlist" sink="uniprotID2" />
              <s:source name="candidate1" />
              <s:source name="candidate2" />
              <s:sink name="protein_molecule1" />
              <s:sink name="uniprotID1" />
              <s:sink name="protein_molecule2" />
              <s:sink name="uniprotID2" />
            </s:scufl>
          </s:workflow>
          <s:iterationstrategy>
            <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="candidate2" />
              <i:iterator name="candidate1" />
            </i:dot>
          </s:iterationstrategy>
        </s:processor>
        <s:link source="ConcatenateRelation:id_relation" sink="relation_ids" />
        <s:link source="FilterHumanProteinPairs:protein_molecule1" sink="FlattenProteinlist1:inputlist" />
        <s:link source="FilterHumanProteinPairs:protein_molecule2" sink="FlattenProteinlist2:inputlist" />
        <s:link source="FilterHumanProteinPairs:uniprotID1" sink="FlattenUniprotlist1:inputlist" />
        <s:link source="FilterHumanProteinPairs:uniprotID2" sink="FlattenUniProtlist2:inputlist" />
        <s:link source="Filter_protein1:filteredlist" sink="FilterHumanProteinPairs:candidate1" />
        <s:link source="Filter_protein2:filteredlist" sink="FilterHumanProteinPairs:candidate2" />
        <s:link source="FlattenProteinlist1:outputlist" sink="ConcatenateRelation:protein_name1" />
        <s:link source="FlattenProteinlist2:outputlist" sink="ConcatenateRelation:protein_name2" />
        <s:link source="FlattenUniProtlist2:outputlist" sink="ConcatenateRelation:uniprot_id2" />
        <s:link source="FlattenUniprotlist1:outputlist" sink="ConcatenateRelation:uniprot_id1" />
        <s:link source="example_interaction_doc:interaction_doc" sink="split_interactionlist:string" />
        <s:link source="split_interaction_regexp:value" sink="Filter_protein1:regex" />
        <s:link source="split_interaction_regexp:value" sink="Filter_protein2:regex" />
        <s:link source="split_interactionlist:split" sink="Filter_protein1:stringlist" />
        <s:link source="split_interactionlist:split" sink="Filter_protein2:stringlist" />
        <s:link source="split_interactions_regexp:value" sink="split_interactionlist:regex" />
        <s:link source="ConcatenateRelation:relation" sink="relation" />
        <s:link source="ConcatenateRelation:relation" sink="relation_term" />
        <s:link source="FlattenProteinlist1:outputlist" sink="protein1" />
        <s:link source="FlattenProteinlist2:outputlist" sink="protein2" />
        <s:link source="FlattenUniProtlist2:outputlist" sink="uniprot_id2" />
        <s:link source="FlattenUniprotlist1:outputlist" sink="uniprot_id1" />
        <s:source name="input_text">
          <s:metadata>
            <s:mimeTypes>
              <s:mimeType>text/plain</s:mimeType>
            </s:mimeTypes>
            <s:description>Plain text to extract proteins from.
e.g.
We have identified a transcriptional repressor, Nrg1, in a genetic screen designed to reveal negative factors involved in the expression of STA1, which encodes a glucoamylase. The NRG1 gene encodes a 25-kDa C2H2 zinc finger protein which specifically binds to two regions in the upstream activation sequence of the STA1 gene, as judged by gel retardation and DNase I footprinting analyses. Disruption of the NRG1 gene causes a fivefold increase in the level of the STA1 transcript in the presence of glucose.</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="protein1" />
        <s:sink name="protein2" />
        <s:sink name="uniprot_id1" />
        <s:sink name="uniprot_id2" />
        <s:sink name="relation" />
        <s:sink name="relation_ids" />
        <s:sink name="relation_term" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="s05_AddDiscoveredProteinToSemanticModel">
    <s:description>Add Protein to Semantic model with Sesame service cf example Discovered Proteins</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:fd7d0d06-932c-45cc-af4a-3d301b0a5a9f" author="Marco Roos (workflow), Willem R. van Hage (services)" title="AddProteinToSemanticModel">Add Protein to Semantic model with Sesame service cf example Discovered Proteins</s:workflowdescription>
        <s:processor name="ObjProp_081028_171550__Protoontology_BioModel__isModelComponentOf" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#isModelComponentOf</s:stringconstant>
        </s:processor>
        <s:processor name="cls_080814_114703__Protoontology_Text__ProteinTerm" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Text.owl#ProteinTerm</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080827_203611__Protoontology_Text__is_Content_Component_Of" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Text.owl#is_Content_Component_Of</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080827_203611__Protoontology_Workflow__has_input" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#has_input</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080827_203611__Protoontology_Workflow__has_output" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#has_output</s:stringconstant>
        </s:processor>
        <s:processor name="cls_080814_114703__Protoontology_BioModel__Protein" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Protein</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_EntrezUniProtURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_EntrezUniProtURI</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080814_114703__Protoontology_MappingBioTextMining__references" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/MappingBioTextMining.owl#references</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_ExpasyUniProtURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_ExpasyUniProtURI</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080814_114703__Protoontology_TextMining__discovered_by" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_iHopUniProtURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_iHopUniProtURI</s:stringconstant>
        </s:processor>
        <s:processor name="AnnProp_080827_203611__Protoontology_seeAlso_iHopQueryURI" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/seeAlso_iHopQueryURI</s:stringconstant>
        </s:processor>
        <s:processor name="DefineSeeAlsoiHopForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/

import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="InstantiateSemanticType_ProteinTerm">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "1999-05-31T13:20:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime

output:
NTriple_InstanceOf_statement
instance_uri
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

instance_uri = instance_ontology_url + "#" + URLEncoder.encode(instance_name, "UTF-8");

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_discovered_by">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSeeAlsoiHopQueryForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineDocComponentRelation">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineRelation_NERCRFhasInput">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_isModelComponent">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSeeAlsoExpasyForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineRelation_NERCRFhasOutput">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ProteinTermAnnotations">
          <s:beanshell>
            <s:scriptvalue>/*
input:
protein_name
uniprot_id

output:
protein_label
protein_comment
protein_term_label
protein_term_comment
*/

if(uniprot_id.length()&gt;0) {
	protein_label = protein_name + "_" + uniprot_id;
	protein_comment = "protein referred to by as " + protein_name + " and UniProt ID: " + uniprot_id;
	protein_term_comment = "protein term " + protein_name + ", identified as name of protein with UniProt ID: " + uniprot_id;
} else {
	protein_label = protein_name; // flawed assumption that proteins without a uniprot id can be identified by their name
	protein_comment = "protein referred to by as " + protein_name + " without a rat, mouse, or human UniProt ID";
	protein_term_comment = "protein term " + protein_name + " as name of protein without rat, mouse, or human UniProt identifier";
}

protein_term_label = protein_label;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">protein_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">uniprot_id</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_label</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_comment</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_term_label</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">protein_term_comment</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="InstantiateSemanticType_Protein">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "1999-05-31T13:20:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime

output:
NTriple_InstanceOf_statement
instance_uri
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

instance_uri = instance_ontology_url + "#" + URLEncoder.encode(instance_name, "UTF-8");

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="DefineSemanticRelation_references">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="DefineSeeAlsoEntrezUniprotForInstance">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Property of Instance
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_DocumentSearchQuery&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#has_lucene_query&gt; "\"EZH2\" AND chromatin"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
*/

/*
variables, input:
instance_uri
annotation_property_uri
seeAlso_url

output:
NTriple_PropertyOfInstance_statement
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

seeAlso_url = URLEncoder.encode(seeAlso_url, "UTF-8");

NTriple_PropertyOfInstance_statement = "&lt;" + instance_uri + "&gt; &lt;"+ annotation_property_uri + "&gt; \"" + seeAlso_url + "\"^^&lt;http://www.w3.org/2001/XMLSchema#anyURI&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">annotation_property_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">seeAlso_url</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_PropertyOfInstance_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="save_as">
          <s:arbitrarywsdl maxretries="3" retrydelay="1000" critical="true">
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="doc_instance_uri" sink="DefineRelation_NERCRFhasInput:range_instance_uri" />
        <s:link source="expasy_URL" sink="DefineSeeAlsoExpasyForInstance:seeAlso_url" />
        <s:link source="protein_name" sink="InstantiateSemanticType_ProteinTerm:instance_name" />
        <s:link source="uniprot_id" sink="InstantiateSemanticType_Protein:instance_name" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_EntrezUniProtURI:value" sink="DefineSeeAlsoEntrezUniprotForInstance:annotation_property_uri" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_ExpasyUniProtURI:value" sink="DefineSeeAlsoExpasyForInstance:annotation_property_uri" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_iHopQueryURI:value" sink="DefineSeeAlsoiHopQueryForInstance:annotation_property_uri" />
        <s:link source="DefineSeeAlsoEntrezUniprotForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSeeAlsoExpasyForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoExpasyForInstance:instance_uri" />
        <s:link source="cls_080814_114703__Protoontology_BioModel__Protein:value" sink="InstantiateSemanticType_Protein:type_uri" />
        <s:link source="cls_080814_114703__Protoontology_Text__ProteinTerm:value" sink="InstantiateSemanticType_ProteinTerm:type_uri" />
        <s:link source="entrez_pubmed_URL" sink="DefineSeeAlsoEntrezUniprotForInstance:seeAlso_url" />
        <s:link source="protein_name" sink="ProteinTermAnnotations:protein_name" />
        <s:link source="uniprot_id" sink="ProteinTermAnnotations:uniprot_id" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoEntrezUniprotForInstance:instance_uri" />
        <s:link source="ProteinTermAnnotations:protein_comment" sink="InstantiateSemanticType_Protein:comment_string" />
        <s:link source="ProteinTermAnnotations:protein_label" sink="InstantiateSemanticType_Protein:label_string" />
        <s:link source="ProteinTermAnnotations:protein_term_comment" sink="InstantiateSemanticType_ProteinTerm:comment_string" />
        <s:link source="ProteinTermAnnotations:protein_term_label" sink="InstantiateSemanticType_ProteinTerm:label_string" />
        <s:link source="datetime" sink="InstantiateSemanticType_Protein:datetime" />
        <s:link source="datetime" sink="InstantiateSemanticType_ProteinTerm:datetime" />
        <s:link source="iHop_search_URL" sink="DefineSeeAlsoiHopQueryForInstance:seeAlso_url" />
        <s:link source="instance_ontology_url" sink="InstantiateSemanticType_Protein:instance_ontology_url" />
        <s:link source="instance_ontology_url" sink="InstantiateSemanticType_ProteinTerm:instance_ontology_url" />
        <s:link source="AnnProp_080827_203611__Protoontology_seeAlso_iHopUniProtURI:value" sink="DefineSeeAlsoiHopForInstance:annotation_property_uri" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="DefineSeeAlsoiHopQueryForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSemanticRelation_discovered_by:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSemanticRelation_isModelComponent:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSemanticRelation_references:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:NTriple_InstanceOf_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoiHopForInstance:instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSeeAlsoiHopQueryForInstance:instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSemanticRelation_references:range_instance_uri" />
        <s:link source="InstantiateSemanticType_ProteinTerm:NTriple_InstanceOf_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="DefineSemanticRelation_discovered_by:domain_instance_uri" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="DefineSemanticRelation_references:domain_instance_uri" />
        <s:link source="ObjProp_080814_114703__Protoontology_MappingBioTextMining__references:value" sink="DefineSemanticRelation_references:relation_uri" />
        <s:link source="ObjProp_080814_114703__Protoontology_TextMining__discovered_by:value" sink="DefineSemanticRelation_discovered_by:relation_uri" />
        <s:link source="iHop_sentence_URL" sink="DefineSeeAlsoiHopForInstance:seeAlso_url" />
        <s:link source="tmp_rdf_output_fileref" sink="save_as:filename" />
        <s:link source="DefineRelation_NERCRFhasInput:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineRelation_NERCRFhasOutput:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSeeAlsoiHopForInstance:NTriple_PropertyOfInstance_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="DefineRelation_NERCRFhasOutput:range_instance_uri" />
        <s:link source="ObjProp_080827_203611__Protoontology_Text__is_Content_Component_Of:value" sink="DefineDocComponentRelation:relation_uri" />
        <s:link source="doc_instance_uri" sink="DefineDocComponentRelation:range_instance_uri" />
        <s:link source="DefineDocComponentRelation:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="ObjProp_080827_203611__Protoontology_Workflow__has_output:value" sink="DefineRelation_NERCRFhasOutput:relation_uri" />
        <s:link source="protein_discovery_process_run_instance_uri" sink="DefineSemanticRelation_discovered_by:range_instance_uri" />
        <s:link source="protein_discovery_service_run_instance_uri" sink="DefineRelation_NERCRFhasInput:domain_instance_uri" />
        <s:link source="protein_discovery_service_run_instance_uri" sink="DefineRelation_NERCRFhasOutput:domain_instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="DefineSemanticRelation_isModelComponent:domain_instance_uri" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="DefineDocComponentRelation:domain_instance_uri" />
        <s:link source="ObjProp_080827_203611__Protoontology_Workflow__has_input:value" sink="DefineRelation_NERCRFhasInput:relation_uri" />
        <s:link source="ObjProp_081028_171550__Protoontology_BioModel__isModelComponentOf:value" sink="DefineSemanticRelation_isModelComponent:relation_uri" />
        <s:link source="model_instance_uri" sink="DefineSemanticRelation_isModelComponent:range_instance_uri" />
        <s:link source="InstantiateSemanticType_Protein:instance_uri" sink="protein_instance" />
        <s:link source="InstantiateSemanticType_ProteinTerm:instance_uri" sink="protein_term_instance" />
        <s:link source="save_as:save_asReturn" sink="output_doc_ref" />
        <s:source name="protein_name">
          <s:metadata>
            <s:description>E.g.
EZH2</s:description>
          </s:metadata>
        </s:source>
        <s:source name="uniprot_id">
          <s:metadata>
            <s:description>e.g.
Q15910</s:description>
          </s:metadata>
        </s:source>
        <s:source name="doc_instance_uri" />
        <s:source name="entrez_pubmed_URL">
          <s:metadata>
            <s:description>http://www.ncbi.nlm.nih.gov/pubmed/</s:description>
          </s:metadata>
        </s:source>
        <s:source name="expasy_URL">
          <s:metadata>
            <s:description>http://www.expasy.ch/</s:description>
          </s:metadata>
        </s:source>
        <s:source name="iHop_sentence_URL" />
        <s:source name="iHop_search_URL" />
        <s:source name="instance_ontology_url">
          <s:metadata>
            <s:description>E.g.
http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:description>
          </s:metadata>
        </s:source>
        <s:source name="model_instance_uri" />
        <s:source name="datetime">
          <s:metadata>
            <s:description>E.g.
2008-08-14T14:37:29+02:00</s:description>
          </s:metadata>
        </s:source>
        <s:source name="tmp_rdf_output_fileref">
          <s:metadata>
            <s:description>E.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:source name="protein_discovery_process_run_instance_uri" />
        <s:source name="protein_discovery_service_run_instance_uri" />
        <s:sink name="protein_instance" />
        <s:sink name="output_doc_ref" />
        <s:sink name="protein_term_instance" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:iterator name="model_instance_uri" />
        <i:dot>
          <i:iterator name="protein_discovery_service_run_instance_uri" />
          <i:iterator name="protein_discovery_process_run_instance_uri" />
          <i:iterator name="doc_instance_uri" />
          <i:iterator name="uniprot_id" />
          <i:iterator name="protein_name" />
          <i:dot>
            <i:iterator name="expasy_URL" />
            <i:iterator name="iHop_search_URL" />
            <i:iterator name="iHop_sentence_URL" />
            <i:iterator name="entrez_pubmed_URL" />
          </i:dot>
        </i:dot>
        <i:dot>
          <i:iterator name="tmp_rdf_output_fileref" />
          <i:iterator name="datetime" />
          <i:iterator name="instance_ontology_url" />
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="s04_AddDocToSemanticModel">
    <s:description>Add Document to Semantic model with Sesame service cf example discovered document</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:c5beeaee-ff9a-4f34-af41-a33a0c19c141" author="Marco Roos (workflow), Willem R. van Hage (service)" title="AddDocumentToSemanticModel">Add Document to Semantic model with Sesame service cf example discovered document</s:workflowdescription>
        <s:processor name="cls_080813_161743__Protoontology_Text__Document" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Text.owl#Document</s:stringconstant>
        </s:processor>
        <s:processor name="DocLabel" boring="true">
          <s:stringconstant>Retrieved PubMed Document</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080827_203611__Protoontology_Workflow__has_input" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#has_input</s:stringconstant>
        </s:processor>
        <s:processor name="DocComment" boring="true">
          <s:stringconstant>Retrieved document, PubMed URL:</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080813_161743__Protoontology_Workflow__has_output" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/Workflow.owl#has_output</s:stringconstant>
        </s:processor>
        <s:processor name="Append" boring="true">
          <s:stringconstant>yes</s:stringconstant>
        </s:processor>
        <s:processor name="ObjProp_080813_161743__Protoontology_TextMining__discovered_by" boring="true">
          <s:stringconstant>http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by</s:stringconstant>
        </s:processor>
        <s:processor name="DefineRelation_DocRetr_hasInput">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="relation_uri" />
              <i:dot>
                <i:iterator name="range_instance_uri" />
                <i:iterator name="domain_instance_uri" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="ConcatDocComment">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="ConcatDocLabel">
          <s:local>org.embl.ebi.escience.scuflworkers.java.StringConcat</s:local>
        </s:processor>
        <s:processor name="ConcatenateStringList">
          <s:defaults>
            <s:default name="delimiter" />
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/* 
Concatenates List of Strings.
Use 'merge all data' on its input to concatenate different inputs.
*/
String s;
Iterator iter = (Iterator) stringlist.iterator();

if (iter.hasNext()) s = iter.next();

while (iter.hasNext()) {
	s = s + delimiter + iter.next();
}

output = s;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="l('text/plain')">stringlist</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">delimiter</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:mergemode input="stringlist" mode="merge" />
        </s:processor>
        <s:processor name="DefineSemanticRelation_has_output">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, 
input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="relation_uri" />
              <i:dot>
                <i:iterator name="range_instance_uri" />
                <i:iterator name="domain_instance_uri" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="DefineSemanticRelation_discovered_by">
          <s:defaults>
            <s:default name="domain_instance_uri">domain_instance_uri</s:default>
            <s:default name="range_instance_uri">range_instance_uri</s:default>
          </s:defaults>
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: RelationByURI
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_InteractionTerm&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/TextMining.owl#discovered_by&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_RelationDiscoveryProcess&gt; .
*/

/*
variables, input:
domain_instance_uri
relation_uri
range_instance_uri

output:
NTriple_Relation_statement
*/

NTriple_Relation_statement = "&lt;" + domain_instance_uri + "&gt; &lt;" + relation_uri + "&gt; &lt;" + range_instance_uri + "&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">domain_instance_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">relation_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">range_instance_uri</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_Relation_statement</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="relation_uri" />
              <i:dot>
                <i:iterator name="range_instance_uri" />
                <i:iterator name="domain_instance_uri" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="InstantiateSemanticType">
          <s:beanshell>
            <s:scriptvalue>/*
N-triple beanshell: Instance of Type including label and comment
*/

/*
conform:
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Proto-ontology/BioModel.owl#Enzyme&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; "an enzyme"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_Enzyme&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; "e.g. the enzyme referred to by as 'EZH2'"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .
&lt;http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/ExampleInstances.owl#ExampleInstance_BioModel&gt; &lt;http://purl.org/dc/elements/1.1/date&gt; "1999-05-31T13:20:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
*/

/*
input:
instance_ontology_url
instance_name
type_uri
label_string
comment_string
datetime

output:
NTriple_InstanceOf_statement
instance_uri
*/
import java.net.URLEncoder;
// e.g. output=URLEncoder.encode(input, "UTF-8");

instance_uri = instance_ontology_url + "#" + URLEncoder.encode(instance_name, "UTF-8");

NTriple_InstanceOf_statement = "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;" + type_uri + "&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; \"" + label_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://www.w3.org/2000/01/rdf-schema#comment&gt; \"" + comment_string + "\"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n";
NTriple_InstanceOf_statement = NTriple_InstanceOf_statement + "&lt;" + instance_uri + "&gt; &lt;http://purl.org/dc/elements/1.1#date&gt; \"" + datetime + "\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .\n";</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_ontology_url</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">instance_name</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">type_uri</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">label_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">comment_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">datetime</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">NTriple_InstanceOf_statement</s:beanshelloutput>
              <s:beanshelloutput s:syntactictype="'text/plain'">instance_uri</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
          <s:iterationstrategy>
            <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
              <i:iterator name="datetime" />
              <i:iterator name="type_uri" />
              <i:iterator name="instance_ontology_url" />
              <i:dot>
                <i:iterator name="comment_string" />
                <i:iterator name="label_string" />
                <i:iterator name="instance_name" />
              </i:dot>
            </i:cross>
          </s:iterationstrategy>
        </s:processor>
        <s:processor name="save_as">
          <s:arbitrarywsdl>
            <s:wsdl>http://aida.science.uva.nl:8888/axis/AidaFiler.jws?wsdl</s:wsdl>
            <s:operation>save_as</s:operation>
          </s:arbitrarywsdl>
        </s:processor>
        <s:link source="pubmed_id" sink="ConcatDocLabel:string2" />
        <s:link source="ConcatDocComment:output" sink="InstantiateSemanticType:comment_string" />
        <s:link source="ConcatDocLabel:output" sink="InstantiateSemanticType:label_string" />
        <s:link source="DocComment:value" sink="ConcatDocComment:string1" />
        <s:link source="DocLabel:value" sink="ConcatDocLabel:string1" />
        <s:link source="instance_ontology_url" sink="InstantiateSemanticType:instance_ontology_url" />
        <s:link source="pubmed_URL" sink="ConcatDocComment:string2" />
        <s:link source="ObjProp_080813_161743__Protoontology_TextMining__discovered_by:value" sink="DefineSemanticRelation_discovered_by:relation_uri" />
        <s:link source="pubmed_URL" sink="InstantiateSemanticType:instance_name" />
        <s:link source="rdf_output_doc_url" sink="save_as:filename" />
        <s:link source="Append:value" sink="save_as:append" />
        <s:link source="ConcatenateStringList:output" sink="save_as:content" />
        <s:link source="DefineSemanticRelation_discovered_by:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="DefineSemanticRelation_has_output:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="InstantiateSemanticType:instance_uri" sink="DefineSemanticRelation_discovered_by:domain_instance_uri" />
        <s:link source="InstantiateSemanticType:instance_uri" sink="DefineSemanticRelation_has_output:range_instance_uri" />
        <s:link source="ObjProp_080813_161743__Protoontology_Workflow__has_output:value" sink="DefineSemanticRelation_has_output:relation_uri" />
        <s:link source="cls_080813_161743__Protoontology_Text__Document:value" sink="InstantiateSemanticType:type_uri" />
        <s:link source="datetime" sink="InstantiateSemanticType:datetime" />
        <s:link source="InstantiateSemanticType:NTriple_InstanceOf_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="query_instance_uri" sink="DefineRelation_DocRetr_hasInput:range_instance_uri" />
        <s:link source="DefineRelation_DocRetr_hasInput:NTriple_Relation_statement" sink="ConcatenateStringList:stringlist" />
        <s:link source="ObjProp_080827_203611__Protoontology_Workflow__has_input:value" sink="DefineRelation_DocRetr_hasInput:relation_uri" />
        <s:link source="docretrieval_process_run_instance_uri" sink="DefineSemanticRelation_discovered_by:range_instance_uri" />
        <s:link source="docretrieval_service_run_instance_uri" sink="DefineRelation_DocRetr_hasInput:domain_instance_uri" />
        <s:link source="docretrieval_service_run_instance_uri" sink="DefineSemanticRelation_has_output:domain_instance_uri" />
        <s:link source="InstantiateSemanticType:instance_uri" sink="doc_instance_uri" />
        <s:link source="save_as:save_asReturn" sink="RDFdoc_ref" />
        <s:source name="pubmed_id" />
        <s:source name="pubmed_URL" />
        <s:source name="instance_ontology_url">
          <s:metadata>
            <s:description>e.g. http://rdf.adaptivedisclosure.org/owl/BioAID/myModel/Enriched-ontology/BioAID_Instances.owl</s:description>
          </s:metadata>
        </s:source>
        <s:source name="rdf_output_doc_url">
          <s:metadata>
            <s:description>e.g.
http://aida.science.uva.nl:9999/aida_public/rdf-output/tmp-rdf-out.rdf</s:description>
          </s:metadata>
        </s:source>
        <s:source name="datetime">
          <s:metadata>
            <s:description>conform
2008-08-14T14:19:00+02:00</s:description>
          </s:metadata>
        </s:source>
        <s:source name="query_instance_uri" />
        <s:source name="docretrieval_process_run_instance_uri" />
        <s:source name="docretrieval_service_run_instance_uri" />
        <s:sink name="doc_instance_uri" />
        <s:sink name="RDFdoc_ref" />
      </s:scufl>
    </s:workflow>
    <s:iterationstrategy>
      <i:cross xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
        <i:dot>
          <i:iterator name="query_instance_uri" />
          <i:iterator name="docretrieval_service_run_instance_uri" />
          <i:iterator name="docretrieval_process_run_instance_uri" />
        </i:dot>
        <i:iterator name="datetime" />
        <i:iterator name="rdf_output_doc_url" />
        <i:iterator name="instance_ontology_url" />
        <i:dot>
          <i:iterator name="pubmed_URL" />
          <i:iterator name="pubmed_id" />
        </i:dot>
      </i:cross>
    </s:iterationstrategy>
  </s:processor>
  <s:processor name="01_ProcessQuery">
    <s:description>Workflow to optimize a Lucene document retrieval query to
1. increase the priority of recent years (in decreasing order from 2009 down to 2002)
2. limit a subsequent search to a specific organism using  a mesh organism tag</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:3d2eebb7-0b04-4979-9aa9-3d39b1464216" author="Marco Roos (workflow)" title="Lucene_bioquery_optimizer_with_synonyms">Workflow to optimize a Lucene document retrieval query to
1. increase the priority of recent years (in decreasing order from 2009 down to 2002)
2. replace protein names with protein synonym strings.
3. provide protein names and uniprot ids for bonifide human protein terms in the input query 

(see subworkflow for details)</s:workflowdescription>
        <s:processor name="Lucene_year_priorities" boring="true">
          <s:stringconstant>year:(2009^10 2008^9 2007^8 2007^7 2006^6 2005^5 2004^4 2003^3 2002^2 2002^1)</s:stringconstant>
        </s:processor>
        <s:processor name="Prioritise_lucene_query">
          <s:beanshell>
            <s:scriptvalue>StringBuffer temp=new StringBuffer();
temp.append("+(");
temp.append(query_string);
temp.append(") ");

/* comment if temporarily out of order: */
temp.append(" +");
temp.append(priority_string);

String lucene_query = temp.toString();</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">query_string</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">priority_string</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/plain'">lucene_query</s:beanshelloutput>
            </s:beanshelloutputlist>
            <s:dependencies s:classloader="iteration" />
          </s:beanshell>
        </s:processor>
        <s:processor name="ProteinQueryToSynonyms">
          <s:description>This workflow creates a query string from the query term using Martijn Schuemie's synonym service. The service is limited to proteins, enzymes and genes. An input query that is a boolean string will be split and processed. Until I find a smarter regular expression only terms withing double quotes will be replaced by synonym strings.</s:description>
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:ecb927cc-a200-4290-9342-302d5fc836ca" author="Marco Roos (workflow) and Martijn Schuemie (services)" title="ExpandQueryAndFilterProteinTerms">This workflow will try to expand an input query with human/rat/mouse protein synonyms using Martijn Schuemie's UniProt-based synonym service. The service is limited to proteins, enzymes and genes. Terms that are bonifide human/rat/mouse protein names are also produced.

Warning note:
Synonym expansion may add ambiguous terms to a query.

This workflow is a fork from ProteinSynonymsToQuery.xml.

Known issues:
* see the query string input metadata
* the Lucene-based tokenizer removes stop-words from multiword tokens, which likely renders the token unrecognizable for the synonym service. (E.g. 'Enhancer of Zeste', becomes "enhancer zeste".)
* replacement is iterative, so nested replacements (creating very long strings) may occur.</s:workflowdescription>
              <s:processor name="FlattenNewQueries">
                <s:local>
                  org.embl.ebi.escience.scuflworkers.java.FlattenList
                  <s:extensions>
                    <s:flattenlist s:depth="2" />
                  </s:extensions>
                </s:local>
              </s:processor>
              <s:processor name="Flatten_SynonymList">
                <s:local>
                  org.embl.ebi.escience.scuflworkers.java.FlattenList
                  <s:extensions>
                    <s:flattenlist s:depth="2" />
                  </s:extensions>
                </s:local>
              </s:processor>
              <s:processor name="QueryToStringIfNotList">
                <s:beanshell>
                  <s:scriptvalue>if(input_list.size()==1) {
	output = input_list.iterator().next().toString();
} else {
	output = input_list;
}</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">input_list</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="RemoveFalseProteins">
                <s:beanshell>
                  <s:scriptvalue>List unitmp = new ArrayList();
List protmp = new ArrayList();
List unilisttmp = new ArrayList();
Iterator val_iter = validated.iterator();
Iterator uni_iter = uniProtIDlist.iterator();
Iterator prot_iter = proteinNameList.iterator();
Iterator unilist_iter = uniProtIDlistList.iterator();
String val;

while (val_iter.hasNext() &amp;&amp; uni_iter.hasNext() &amp;&amp; prot_iter.hasNext() &amp;&amp; unilist_iter.hasNext()) {
	val=val_iter.next();
	if (val=="True" || val == "true") {
		unitmp.add(uni_iter.next());
		protmp.add(prot_iter.next());
		unilisttmp.add(unilist_iter.next());
	}
}
		 
cleanUniProtIDlist = unitmp;
cleanProteinNamelist = protmp;
cleanUniProtIDlistList = unilisttmp;</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">validated</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="l('text/plain')">uniProtIDlist</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="l('text/plain')">proteinNameList</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="l(l('text/plain'))">uniProtIDlistList</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">cleanUniProtIDlist</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">cleanProteinNamelist</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="l(l('text/plain'))">cleanUniProtIDlistList</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
                <s:iterationstrategy>
                  <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
                    <i:iterator name="uniProtIDlistList" />
                    <i:iterator name="proteinNameList" />
                    <i:iterator name="uniProtIDlist" />
                    <i:iterator name="validated" />
                  </i:dot>
                </s:iterationstrategy>
              </s:processor>
              <s:processor name="Concat_synonyms">
                <s:beanshell>
                  <s:scriptvalue>import java.util.*;
String synstring=query_term;
String syn;
Iterator iterator = synonymlist.iterator();

while ( iterator.hasNext() ) 
{
	syn = ((String) iterator.next());
	synstring = synstring + " OR " + "\"" + syn + "\"";
}
new_query = synstring;</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">synonymlist</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">query_term</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">new_query</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
                <s:mergemode input="synonymlist" mode="merge" />
                <s:iterationstrategy>
                  <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
                    <i:iterator name="query_term" />
                    <i:iterator name="synonymlist" />
                  </i:dot>
                </s:iterationstrategy>
              </s:processor>
              <s:processor name="ListFindAndReplace">
                <s:beanshell>
                  <s:scriptvalue>// replace words in the input query by synonym strings plus the original
// input: the input query
// findstringlist: list of words to be replaced
// replacestringlist: list of synonym string to replace items in the findstringlist
// find and replaces string lists form pairs (should be of equal length)

import java.util.regex.*;

String tmp=(String) input;
String findstring;
Iterator find_iterator = findstringlist.iterator();
Iterator replace_iterator = replacestringlist.iterator();
int i=0;

/* iteration 1: replace with placeholders to prevent replacing replacements */
while (find_iterator.hasNext())
{
	findstring = ((String) find_iterator.next().toString());
	replacestring = "§" + i + "¡";
	i=i+1;
	
	Pattern p = Pattern.compile("[\"]*"+findstring+"[\"]*"); 
	Matcher m = p.matcher(tmp);

	tmp = (String) m.replaceAll(replacestring);
}

i=0;
while (replace_iterator.hasNext())
{
	findstring = "§" + i + "¡";
	i=i+1;
	replacestring = ((String) replace_iterator.next().toString());
	
	Pattern p = Pattern.compile("[\"]*"+findstring+"[\"]*"); 
	Matcher m = p.matcher(tmp);

	tmp = (String) m.replaceAll("("+replacestring+")");
}

output = tmp;</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="l('text/plain')">findstringlist</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="l('text/plain')">replacestringlist</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
                <s:mergemode input="input" mode="merge" />
                <s:iterationstrategy>
                  <i:dot xmlns:i="http://org.embl.ebi.escience/xscufliteration/0.1beta10">
                    <i:dot>
                      <i:iterator name="findstringlist" />
                      <i:iterator name="replacestringlist" />
                    </i:dot>
                    <i:iterator name="input" />
                  </i:dot>
                </s:iterationstrategy>
              </s:processor>
              <s:processor name="ReListEmpty">
                <s:beanshell>
                  <s:scriptvalue>/* if list is empty replaces it with list of empty lists
tested on 1-deep lists
in
listOfLists
out
listOfLists_out
*/
List newListOfLists = new ArrayList();

if (listOfLists_in.size()&lt;=0) {
	List newList = new ArrayList();
	newListOfLists.add((List) newList);
} else {
	newListOfLists = listOfLists_in;
}

listOfLists_out = (List) newListOfLists;</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">listOfLists_in</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">listOfLists_out</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="FilterProteins">
                <s:description>This workflow filters protein_molecule-labeled terms from an input string(list). The result is a tagged list of proteins (disregarding false positives in the input).

Internal information:
This workflow is a copy of 'filter_protein_molecule_MR3' used for the NBIC poster (now in Archive).</s:description>
                <s:workflow>
                  <s:scufl version="0.2" log="0">
                    <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:df6063f9-b469-4d56-aecc-a62db4bcb3ad" author="Marco Roos (AID)" title="FilterHumanProteinsByUniprot">This workflow filters protein_molecule-labeled terms from an input string(list). The result is a tagged list of proteins (disregarding false positives in the input).

Internal information:
This workflow is a copy of 'filter_protein_molecule_MR3' used for the NBIC poster (now in Archive).</s:workflowdescription>
                    <s:processor name="validatePotentialProteinName">
                      <s:beanshell>
                        <s:scriptvalue>List tmp_list = new ArrayList();
String tmp_id;
String tmp_name;

if (!(uniProtIDlist.isEmpty())) {
	tmp_list=uniProtIDlist;
	tmp_name = potentialProteinName;
	Iterator iter = uniProtIDlist.iterator();
	if (uniProtIDlist.size()&gt;1) {
		tmp_id = "OneOf";
		while (iter.hasNext()) {
			tmp_id=tmp_id+"_"+iter.next().toString();
		}
	} else {
		tmp_id = iter.next().toString();
	}
	validated="True";
} else {
	tmp_list.add("NO_UNIPROT_ID_FOR_"+potentialProteinName);
	tmp_id =  "NO_UNIPROT_ID_FOR_"+potentialProteinName;
	tmp_name = "NO_UNIPROT_ID_FOR_"+potentialProteinName;
	validated="False";
}

validatedUniProtIDlist = tmp_list;
validatedUniProtID = tmp_id;
validatedProteinName = tmp_name;</s:scriptvalue>
                        <s:beanshellinputlist>
                          <s:beanshellinput s:syntactictype="l('text/plain')">uniProtIDlist</s:beanshellinput>
                          <s:beanshellinput s:syntactictype="'text/plain'">potentialProteinName</s:beanshellinput>
                        </s:beanshellinputlist>
                        <s:beanshelloutputlist>
                          <s:beanshelloutput s:syntactictype="l('text/plain')">validatedUniProtIDlist</s:beanshelloutput>
                          <s:beanshelloutput s:syntactictype="'text/plain'">validatedUniProtID</s:beanshelloutput>
                          <s:beanshelloutput s:syntactictype="'text/plain'">validatedProteinName</s:beanshelloutput>
                          <s:beanshelloutput s:syntactictype="'text/plain'">validated</s:beanshelloutput>
                        </s:beanshelloutputlist>
                        <s:dependencies s:classloader="iteration" />
                      </s:beanshell>
                    </s:processor>
                    <s:processor name="getUniprotID">
                      <s:arbitrarywsdl retrydelay="1">
                        <s:wsdl>http://biosemantics.org:8080/axis/services/SynsetServer/SynsetServer.jws?wsdl</s:wsdl>
                        <s:operation>getUniprotID</s:operation>
                      </s:arbitrarywsdl>
                    </s:processor>
                    <s:link source="input_string" sink="getUniprotID:term" />
                    <s:link source="getUniprotID:getUniprotIDReturn" sink="validatePotentialProteinName:uniProtIDlist" />
                    <s:link source="input_string" sink="validatePotentialProteinName:potentialProteinName" />
                    <s:link source="input_string" sink="potential_protein_name" />
                    <s:link source="validatePotentialProteinName:validated" sink="validated" />
                    <s:link source="validatePotentialProteinName:validatedProteinName" sink="validated_protein_name" />
                    <s:link source="validatePotentialProteinName:validatedUniProtID" sink="uniprotID" />
                    <s:link source="validatePotentialProteinName:validatedUniProtIDlist" sink="validatedUniProtIDlist" />
                    <s:source name="input_string" />
                    <s:sink name="validated_protein_name" />
                    <s:sink name="uniprotID" />
                    <s:sink name="validatedUniProtIDlist" />
                    <s:sink name="validated" />
                    <s:sink name="potential_protein_name" />
                  </s:scufl>
                </s:workflow>
              </s:processor>
              <s:processor name="getSynsets">
                <s:arbitrarywsdl>
                  <s:wsdl>http://biosemantics.org:8080/axis/services/SynsetServer/SynsetServer.jws?wsdl</s:wsdl>
                  <s:operation>getSynsets</s:operation>
                </s:arbitrarywsdl>
              </s:processor>
              <s:processor name="SplitQuery">
                <s:description>Splits and input query string into its parts. Works for queries that contain search terms, search phrases between double quotes, connected by AND or OR. Behaviour undetermined when other characters such as +, -, or brackets are used. Should work now for well formed patterns with bracketed substrings separated by AND/OR/AND NOT/OR NOT, e.g. (Topic1) AND NOT (Topic2), but not extensively tested.</s:description>
                <s:workflow>
                  <s:scufl version="0.2" log="0">
                    <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:f1d2b701-3cc3-49a9-8cab-dfc3f1e6f5a6" author="Marco Roos (workflow), Edgar Meij (service)" title="Lucene query tokenizer plus">Extracts query terms or phrases from a (Lucene) boolean query.

Known issues:
The Lucene tokenizer is used. This has some side-effects. The conversion of single word terms to lower case is reversed in this workflow, but the drop of stop words in multi-term tokens is not (e.g. 'Enhancer of Zeste' will become 'enhancer zeste').</s:workflowdescription>
                    <s:processor name="Remove_duplicate_strings">
                      <s:local>org.embl.ebi.escience.scuflworkers.java.StringStripDuplicates</s:local>
                    </s:processor>
                    <s:processor name="queryToArray">
                      <s:description>Use this method to tokenize a Lucene Query into terms.</s:description>
                      <s:arbitrarywsdl>
                        <s:wsdl>http://aida.science.uva.nl:8888/axis/services/tokenize?wsdl</s:wsdl>
                        <s:operation>queryToArray</s:operation>
                      </s:arbitrarywsdl>
                    </s:processor>
                    <s:link source="queryString" sink="queryToArray:in" />
                    <s:link source="queryToArray:queryToArrayReturn" sink="Remove_duplicate_strings:stringlist" />
                    <s:link source="Remove_duplicate_strings:strippedlist" sink="queryList" />
                    <s:source name="queryString">
                      <s:metadata>
                        <s:description>Queries that contain search terms, search phrases between double quotes, possibly connected by AND or OR. Behaviour undetermined when other characters such as +, -, or brackets are used.

E.g.
EZH2 +(HDAC1 AND SMC1) OR "Enhancer of Zeste Drosophila Homologue 2" AND ('P53' or 'ftsQ')</s:description>
                      </s:metadata>
                    </s:source>
                    <s:sink name="queryList" />
                  </s:scufl>
                </s:workflow>
              </s:processor>
              <s:link source="Concat_synonyms:new_query" sink="ListFindAndReplace:replacestringlist" />
              <s:link source="FilterProteins:uniprotID" sink="RemoveFalseProteins:uniProtIDlist" />
              <s:link source="FilterProteins:validated" sink="RemoveFalseProteins:validated" />
              <s:link source="FilterProteins:validatedUniProtIDlist" sink="RemoveFalseProteins:uniProtIDlistList" />
              <s:link source="FilterProteins:validated_protein_name" sink="RemoveFalseProteins:proteinNameList" />
              <s:link source="ListFindAndReplace:output" sink="FlattenNewQueries:inputlist" />
              <s:link source="ReListEmpty:listOfLists_out" sink="Flatten_SynonymList:inputlist" />
              <s:link source="SplitQuery:queryList" sink="Concat_synonyms:query_term" />
              <s:link source="SplitQuery:queryList" sink="FilterProteins:input_string" />
              <s:link source="SplitQuery:queryList" sink="ListFindAndReplace:findstringlist" />
              <s:link source="query_string" sink="ListFindAndReplace:input" />
              <s:link source="query_string" sink="SplitQuery:queryString" />
              <s:link source="FlattenNewQueries:outputlist" sink="QueryToStringIfNotList:input_list" />
              <s:link source="Flatten_SynonymList:outputlist" sink="Concat_synonyms:synonymlist" />
              <s:link source="SplitQuery:queryList" sink="getSynsets:term" />
              <s:link source="getSynsets:getSynsetsReturn" sink="ReListEmpty:listOfLists_in" />
              <s:link source="QueryToStringIfNotList:output" sink="new_query" />
              <s:link source="RemoveFalseProteins:cleanProteinNamelist" sink="protein_name" />
              <s:link source="RemoveFalseProteins:cleanUniProtIDlist" sink="uniprotID" />
              <s:link source="RemoveFalseProteins:cleanUniProtIDlistList" sink="uniprotIDlist" />
              <s:source name="query_string">
                <s:metadata>
                  <s:description>(Boolean) query. Protein/gene/enzyme names registered as human, rat, or mouse protein at UniProt will be replaced by a string of synonyms including the original name. Other types of names are left as they are. 

Example inputs:
"EZH2"
"Enhancer of Zeste" AND "HDAC1" AND "chromatin"
EZH2 +(HDAC1 AND SMC1) OR "Enhancer of Zeste Drosophila Homologue 2" AND ('P53' or 'ftsQ')

Known issues:
* It is assumed that each item in the query is a separate biological term, including synonyms that the BioSemantics synonym/uniprot service knows about will lead to unnecessary redundancy in the new query.</s:description>
                </s:metadata>
              </s:source>
              <s:sink name="new_query" />
              <s:sink name="protein_name" />
              <s:sink name="uniprotID" />
              <s:sink name="uniprotIDlist" />
            </s:scufl>
          </s:workflow>
        </s:processor>
        <s:link source="Lucene_year_priorities:value" sink="Prioritise_lucene_query:priority_string" />
        <s:link source="query_string" sink="ProteinQueryToSynonyms:query_string" />
        <s:link source="ProteinQueryToSynonyms:new_query" sink="Prioritise_lucene_query:query_string" />
        <s:link source="Prioritise_lucene_query:lucene_query" sink="extended_lucene_query" />
        <s:link source="ProteinQueryToSynonyms:protein_name" sink="protein_name" />
        <s:link source="ProteinQueryToSynonyms:uniprotID" sink="UniProtID" />
        <s:link source="ProteinQueryToSynonyms:uniprotIDlist" sink="UniProtIDlist" />
        <s:source name="query_string">
          <s:metadata>
            <s:description>Lucene query string</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="extended_lucene_query">
          <s:metadata>
            <s:description>Lucene query based on the input query with the addition of:
1. A Lucene string to give recent years higher priority (in decreasing order from 2009 down to 2002)
2. A mesh organism term to limit subsequent searches</s:description>
          </s:metadata>
        </s:sink>
        <s:sink name="protein_name" />
        <s:sink name="UniProtID" />
        <s:sink name="UniProtIDlist" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="03_ExtractProteins_UniProtValidation">
    <s:description>Workflow to extract proteins from text, followed by filtering protein names known as human protein names.</s:description>
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:c0a963bc-2343-4d31-aa8c-304bfe3a6289" author="Marco Roos (workflow), Martijn Schuemie (service)" title="ExtractProteinsFromText_UniProtValidation">Workflow to extract proteins from text, followed by filtering protein names known as human protein names.</s:workflowdescription>
        <s:processor name="ValidateUniProtProteins">
          <s:description>This workflow filters protein_molecule-labeled terms from an input string(list). The result is a tagged list of proteins (disregarding false positives in the input).

Internal information:
This workflow is a copy of 'filter_protein_molecule_MR3' used for the NBIC poster (now in Archive).</s:description>
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:df6063f9-b469-4d56-aecc-a62db4bcb3ad" author="Marco Roos (AID)" title="FilterHumanProteinsByUniprot">This workflow filters protein_molecule-labeled terms from an input string(list). The result is a tagged list of proteins (disregarding false positives in the input).

Internal information:
This workflow is a copy of 'filter_protein_molecule_MR3' used for the NBIC poster (now in Archive).</s:workflowdescription>
              <s:processor name="validatePotentialProteinName">
                <s:beanshell>
                  <s:scriptvalue>List tmp_list = new ArrayList();
String tmp_id;
String tmp_name;

if (!(uniProtIDlist.isEmpty())) {
	tmp_list=uniProtIDlist;
	tmp_name = potentialProteinName;
	Iterator iter = uniProtIDlist.iterator();
	if (uniProtIDlist.size()&gt;1) {
		tmp_id = "OneOf";
		while (iter.hasNext()) {
			tmp_id=tmp_id+"_"+iter.next().toString();
		}
	} else {
		tmp_id = iter.next().toString();
	}
	validated="True";
} else {
	tmp_list.add("NO_UNIPROT_ID_FOR_"+potentialProteinName);
	tmp_id =  "NO_UNIPROT_ID_FOR_"+potentialProteinName;
	tmp_name = "NO_UNIPROT_ID_FOR_"+potentialProteinName;
	validated="False";
}

validatedUniProtIDlist = tmp_list;
validatedUniProtID = tmp_id;
validatedProteinName = tmp_name;</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="l('text/plain')">uniProtIDlist</s:beanshellinput>
                    <s:beanshellinput s:syntactictype="'text/plain'">potentialProteinName</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="l('text/plain')">validatedUniProtIDlist</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="'text/plain'">validatedUniProtID</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="'text/plain'">validatedProteinName</s:beanshelloutput>
                    <s:beanshelloutput s:syntactictype="'text/plain'">validated</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="getUniprotID">
                <s:arbitrarywsdl retrydelay="1">
                  <s:wsdl>http://biosemantics.org:8080/axis/services/SynsetServer/SynsetServer.jws?wsdl</s:wsdl>
                  <s:operation>getUniprotID</s:operation>
                </s:arbitrarywsdl>
              </s:processor>
              <s:link source="input_string" sink="getUniprotID:term" />
              <s:link source="getUniprotID:getUniprotIDReturn" sink="validatePotentialProteinName:uniProtIDlist" />
              <s:link source="input_string" sink="potential_protein_name" />
              <s:link source="input_string" sink="validatePotentialProteinName:potentialProteinName" />
              <s:link source="validatePotentialProteinName:validated" sink="validated" />
              <s:link source="validatePotentialProteinName:validatedProteinName" sink="validated_protein_name" />
              <s:link source="validatePotentialProteinName:validatedUniProtID" sink="uniprotID" />
              <s:link source="validatePotentialProteinName:validatedUniProtIDlist" sink="validatedUniProtIDlist" />
              <s:source name="input_string" />
              <s:sink name="validated_protein_name" />
              <s:sink name="uniprotID" />
              <s:sink name="validatedUniProtIDlist" />
              <s:sink name="validated" />
              <s:sink name="potential_protein_name" />
            </s:scufl>
          </s:workflow>
        </s:processor>
        <s:processor name="ExtractProteinsFromText">
          <s:description>Workflow to extract proteins from text

Two methods are combined:
Named entity recognition using LingPipe (NERecognize)
Named entity recognition using Conditional Random Fields (applyCRF)
Both are based on machine learning methods.

Default inputs:
Model: 1 = BioCreative I
OutputMode: 1 = IOB format; 2 = SGML format; 3 = a list of entities; 4 = ABNER format
Tokenization: 1 = activate tokenization (makes no difference in practice)
testFile is expected to be a piece of text (string)</s:description>
          <s:workflow>
            <s:scufl version="0.2" log="0">
              <s:workflowdescription lsid="urn:lsid:net.sf.taverna:wfDefinition:ec3e8ad0-b45b-4dbb-b5a9-da5e273d82c1" author="Marco Roos (workflow) and Sophia Katrenko (service)" title="ProteinExtractionFromText">Workflow to extract proteins from text

Two methods are combined:
Named entity recognition using LingPipe (NERecognize)
Named entity recognition using Conditional Random Fields (applyCRF)
Both are based on machine learning methods.

Default inputs:
Model: 1 = BioCreative I
OutputMode: 1 = IOB format; 2 = SGML format; 3 = a list of entities; 4 = ABNER format
Tokenization: 1 = activate tokenization (makes no difference in practice)
testFile is expected to be a piece of text (string)</s:workflowdescription>
              <s:processor name="FilterProteinsFromListFormat" boring="true">
                <s:stringconstant>PROTEIN	\[(.+)\]</s:stringconstant>
              </s:processor>
              <s:processor name="outputMode" boring="true">
                <s:stringconstant>3</s:stringconstant>
              </s:processor>
              <s:processor name="split_regexp" boring="true">
                <s:stringconstant>\n</s:stringconstant>
              </s:processor>
              <s:processor name="modelFile" boring="true">
                <s:stringconstant>1</s:stringconstant>
              </s:processor>
              <s:processor name="tokenization" boring="true">
                <s:stringconstant>1</s:stringconstant>
              </s:processor>
              <s:processor name="Remove_duplicate_strings">
                <s:local>org.embl.ebi.escience.scuflworkers.java.StringStripDuplicates</s:local>
              </s:processor>
              <s:processor name="SplitProteinsList">
                <s:local>org.embl.ebi.escience.scuflworkers.java.SplitByRegex</s:local>
              </s:processor>
              <s:processor name="String_list_union">
                <s:local>org.embl.ebi.escience.scuflworkers.java.StringSetUnion</s:local>
              </s:processor>
              <s:processor name="FilterProteins">
                <s:defaults>
                  <s:default name="group">1</s:default>
                </s:defaults>
                <s:local>org.embl.ebi.escience.scuflworkers.java.RegularExpressionStringList</s:local>
              </s:processor>
              <s:processor name="Trim_protein_gene">
                <s:beanshell>
                  <s:scriptvalue>import java.util.*;

String tmp;

tmp = input;

if (input.endsWith(" protein")) {
	tmp = input.substring(0,input.length()-8);
}

if (input.endsWith(" gene")) {
	tmp = input.substring(0,input.length()-5);
}

output = tmp;</s:scriptvalue>
                  <s:beanshellinputlist>
                    <s:beanshellinput s:syntactictype="'text/plain'">input</s:beanshellinput>
                  </s:beanshellinputlist>
                  <s:beanshelloutputlist>
                    <s:beanshelloutput s:syntactictype="'text/plain'">output</s:beanshelloutput>
                  </s:beanshelloutputlist>
                  <s:dependencies s:classloader="iteration" />
                </s:beanshell>
              </s:processor>
              <s:processor name="applyCRF">
                <s:arbitrarywsdl>
                  <s:wsdl>http://aida.science.uva.nl:8888/axis/services/CRFapply?wsdl</s:wsdl>
                  <s:operation>apply</s:operation>
                </s:arbitrarywsdl>
                <s:alternate>
                  <s:arbitrarywsdl>
                    <s:wsdl>http://aida.science.uva.nl:8888/axis/services/CRFapply?wsdl</s:wsdl>
                    <s:operation>apply</s:operation>
                  </s:arbitrarywsdl>
                  <s:outputmap key="applyReturn" value="applyReturn" />
                  <s:outputmap key="attachmentList" value="attachmentList" />
                  <s:inputmap key="testFile" value="testFile" />
                  <s:inputmap key="tokenization" value="tokenization" />
                  <s:inputmap key="outputMode" value="outputMode" />
                  <s:inputmap key="modelFile" value="modelFile" />
                </s:alternate>
                <s:alternate>
                  <s:arbitrarywsdl>
                    <s:wsdl>http://aida.science.uva.nl:9999/axis/services/CRFapply?wsdl</s:wsdl>
                    <s:operation>apply</s:operation>
                  </s:arbitrarywsdl>
                  <s:outputmap key="applyReturn" value="applyReturn" />
                  <s:outputmap key="attachmentList" value="attachmentList" />
                  <s:inputmap key="testFile" value="testFile" />
                  <s:inputmap key="tokenization" value="tokenization" />
                  <s:inputmap key="outputMode" value="outputMode" />
                  <s:inputmap key="modelFile" value="modelFile" />
                </s:alternate>
              </s:processor>
              <s:link source="FilterProteins:filteredlist" sink="String_list_union:list1" />
              <s:link source="FilterProteins:filteredlist" sink="Trim_protein_gene:input" />
              <s:link source="FilterProteinsFromListFormat:value" sink="FilterProteins:regex" />
              <s:link source="SplitProteinsList:split" sink="FilterProteins:stringlist" />
              <s:link source="String_list_union:union" sink="Remove_duplicate_strings:stringlist" />
              <s:link source="Trim_protein_gene:output" sink="String_list_union:list2" />
              <s:link source="input_text" sink="applyCRF:testFile" />
              <s:link source="applyCRF:applyReturn" sink="SplitProteinsList:string" />
              <s:link source="modelFile:value" sink="applyCRF:modelFile" />
              <s:link source="outputMode:value" sink="applyCRF:outputMode" />
              <s:link source="split_regexp:value" sink="SplitProteinsList:regex" />
              <s:link source="tokenization:value" sink="applyCRF:tokenization" />
              <s:link source="Remove_duplicate_strings:strippedlist" sink="extracted_protein" />
              <s:source name="input_text">
                <s:metadata>
                  <s:description>Example:
We have identified a transcriptional repressor, Nrg1, in a genetic screen designed to reveal negative factors involved in the expression of STA1, which encodes a glucoamylase. The NRG1 gene encodes a 25-kDa C2H2 zinc finger protein which specifically binds to two regions in the upstream activation sequence of the STA1 gene, as judged by gel retardation and DNase I footprinting analyses. Disruption of the NRG1 gene causes a fivefold increase in the level of the STA1 transcript in the presence of glucose.</s:description>
                </s:metadata>
              </s:source>
              <s:sink name="extracted_protein" />
            </s:scufl>
          </s:workflow>
        </s:processor>
        <s:link source="input_text" sink="ExtractProteinsFromText:input_text" />
        <s:link source="ExtractProteinsFromText:extracted_protein" sink="ValidateUniProtProteins:input_string" />
        <s:link source="ValidateUniProtProteins:potential_protein_name" sink="protein_name" />
        <s:link source="ValidateUniProtProteins:uniprotID" sink="uniprotID" />
        <s:link source="ValidateUniProtProteins:validatedUniProtIDlist" sink="uniProtIDlist" />
        <s:link source="ValidateUniProtProteins:validated_protein_name" sink="validated_protein_name" />
        <s:source name="input_text">
          <s:metadata>
            <s:description>Plain text to extract proteins from.
e.g.
We have identified a transcriptional repressor, Nrg1, in a genetic screen designed to reveal negative factors involved in the expression of STA1, which encodes a glucoamylase. The NRG1 gene encodes a 25-kDa C2H2 zinc finger protein which specifically binds to two regions in the upstream activation sequence of the STA1 gene, as judged by gel retardation and DNase I footprinting analyses. Disruption of the NRG1 gene causes a fivefold increase in the level of the STA1 transcript in the presence of glucose.</s:description>
          </s:metadata>
        </s:source>
        <s:sink name="uniprotID" />
        <s:sink name="protein_name" />
        <s:sink name="uniProtIDlist" />
        <s:sink name="validated_protein_name" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:link source="aida_magic_word" sink="s00_InitializeSemanticStorage:aida_magic_word" />
  <s:link source="aida_magic_word" sink="s08_AddRdfToRepository:aida_magic_word" />
  <s:link source="max_document_nr" sink="02_RetrieveDocumentsFromMedline:maxHits" />
  <s:link source="query" sink="01_ProcessQuery:query_string" />
  <s:link source="01_ProcessQuery:UniProtID" sink="s03b_AddQueryProteinsToSemanticModel:uniprot_id" />
  <s:link source="01_ProcessQuery:UniProtIDlist" sink="01b_UniProtXrefURLs:UniProtID" />
  <s:link source="01_ProcessQuery:extended_lucene_query" sink="01b_CalculateQueryFrequency:query" />
  <s:link source="01_ProcessQuery:extended_lucene_query" sink="02_RetrieveDocumentsFromMedline:queryString" />
  <s:link source="01_ProcessQuery:extended_lucene_query" sink="05_ScoreExtractedProteins:query" />
  <s:link source="01_ProcessQuery:extended_lucene_query" sink="s03_AddExpandedQueryToSemanticModel:query" />
  <s:link source="01_ProcessQuery:protein_name" sink="s03b_AddQueryProteinsToSemanticModel:protein_name" />
  <s:link source="01b_CalculateQueryFrequency:poi_count_in_corpus" sink="05_ScoreExtractedProteins:query_frequency" />
  <s:link source="01b_UniProtXrefURLs:EntrezUniProtURL" sink="s03b_AddQueryProteinsToSemanticModel:entrez_pubmed_URL" />
  <s:link source="01b_UniProtXrefURLs:ExpasyUniProtURL" sink="s03b_AddQueryProteinsToSemanticModel:expasy_URL" />
  <s:link source="01b_UniProtXrefURLs:iHopSearchURL" sink="s03b_AddQueryProteinsToSemanticModel:iHop_search_URL" />
  <s:link source="01b_UniProtXrefURLs:iHopSentencesURL" sink="s03b_AddQueryProteinsToSemanticModel:iHop_sentence_URL" />
  <s:link source="02_RetrieveDocumentsFromMedline:abstract" sink="03_ExtractProteins_UniProtValidation:input_text" />
  <s:link source="02_RetrieveDocumentsFromMedline:abstract" sink="04_ExtractProteinRelations_HomoSapiens:input_text" />
  <s:link source="02_RetrieveDocumentsFromMedline:pubmed_URL" sink="s04_AddDocToSemanticModel:pubmed_URL" />
  <s:link source="02_RetrieveDocumentsFromMedline:pubmed_id" sink="s04_AddDocToSemanticModel:pubmed_id" />
  <s:link source="03_ExtractProteins_UniProtValidation:protein_name" sink="05_ScoreExtractedProteins:discovered_protein" />
  <s:link source="03_ExtractProteins_UniProtValidation:protein_name" sink="CountProteinsPerDocument:list" />
  <s:link source="03_ExtractProteins_UniProtValidation:protein_name" sink="s05_AddDiscoveredProteinToSemanticModel:protein_name" />
  <s:link source="03_ExtractProteins_UniProtValidation:uniProtIDlist" sink="06_UniProtXrefURLs_iHopBYPASS:UniProtID" />
  <s:link source="03_ExtractProteins_UniProtValidation:uniprotID" sink="s05_AddDiscoveredProteinToSemanticModel:uniprot_id" />
  <s:link source="04_ExtractProteinRelations_HomoSapiens:protein1" sink="s06_AddProteinRelationToSemanticModel:protein_name1" />
  <s:link source="04_ExtractProteinRelations_HomoSapiens:protein2" sink="s06_AddProteinRelationToSemanticModel:protein_name2" />
  <s:link source="04_ExtractProteinRelations_HomoSapiens:relation_term" sink="s06_AddProteinRelationToSemanticModel:interaction_term" />
  <s:link source="04_ExtractProteinRelations_HomoSapiens:uniprot_id1" sink="s06_AddProteinRelationToSemanticModel:uniprot_id1" />
  <s:link source="04_ExtractProteinRelations_HomoSapiens:uniprot_id2" sink="s06_AddProteinRelationToSemanticModel:uniprot_id2" />
  <s:link source="05_ScoreExtractedProteins:min_log_likelihood" sink="s07_AddScoreToSemanticModel:score_value" />
  <s:link source="06_UniProtXrefURLs_iHopBYPASS:EntrezUniProtURL" sink="s05_AddDiscoveredProteinToSemanticModel:entrez_pubmed_URL" />
  <s:link source="06_UniProtXrefURLs_iHopBYPASS:ExpasyUniProtURL" sink="s05_AddDiscoveredProteinToSemanticModel:expasy_URL" />
  <s:link source="06_UniProtXrefURLs_iHopBYPASS:iHopSearchURL" sink="s05_AddDiscoveredProteinToSemanticModel:iHop_search_URL" />
  <s:link source="06_UniProtXrefURLs_iHopBYPASS:iHopSentencesURL" sink="s05_AddDiscoveredProteinToSemanticModel:iHop_sentence_URL" />
  <s:link source="CloneStringToList_DocumentInstance:clones" sink="s05_AddDiscoveredProteinToSemanticModel:doc_instance_uri" />
  <s:link source="CloneStringToList_NERprocessRunInstance:clones" sink="s05_AddDiscoveredProteinToSemanticModel:protein_discovery_process_run_instance_uri" />
  <s:link source="CloneStringToList_NERserviceRunInstance:clones" sink="s05_AddDiscoveredProteinToSemanticModel:protein_discovery_service_run_instance_uri" />
  <s:link source="CountProteinsPerDocument:count" sink="CloneStringToList_DocumentInstance:copy_number" />
  <s:link source="CountProteinsPerDocument:count" sink="CloneStringToList_NERprocessRunInstance:copy_number" />
  <s:link source="CountProteinsPerDocument:count" sink="CloneStringToList_NERserviceRunInstance:copy_number" />
  <s:link source="MedLineTotalDocCount:value" sink="01b_CalculateQueryFrequency:corpus_total_doc_count" />
  <s:link source="MedLineTotalDocCount:value" sink="05_ScoreExtractedProteins:PubMedTotalDocCount" />
  <s:link source="MinLogLikelhoodScoreDescription:value" sink="s07_AddScoreToSemanticModel:discovery_score_method" />
  <s:link source="Timestamp:now_ISO8601" sink="p01_AddWorkflowToSemanticModel:timestamp_iso8601" />
  <s:link source="Timestamp:now_ISO8601" sink="p02_AddDocumentDiscoveryToSemanticModel:timestamp_iso8601" />
  <s:link source="Timestamp:now_ISO8601" sink="p03_AddProteinDiscoveryToSemanticModel:timestamp_iso8601" />
  <s:link source="Timestamp:now_ISO8601" sink="s02_AddOriginalQueryToSemanticModel:datetime" />
  <s:link source="Timestamp:now_ISO8601" sink="s03_AddExpandedQueryToSemanticModel:datetime" />
  <s:link source="Timestamp:now_ISO8601" sink="s03b_AddQueryProteinsToSemanticModel:datetime" />
  <s:link source="Timestamp:now_ISO8601" sink="s04_AddDocToSemanticModel:datetime" />
  <s:link source="Timestamp:now_ISO8601" sink="s05_AddDiscoveredProteinToSemanticModel:datetime" />
  <s:link source="Timestamp:now_ISO8601" sink="s07_AddScoreToSemanticModel:datetime" />
  <s:link source="Timestamp:now_short" sink="p01_AddWorkflowToSemanticModel:timestamp_shortstring" />
  <s:link source="Timestamp:now_short" sink="p02_AddDocumentDiscoveryToSemanticModel:timestamp_shortstring" />
  <s:link source="Timestamp:now_short" sink="p03_AddProteinDiscoveryToSemanticModel:timestamp_shortstring" />
  <s:link source="clear_knowledge_repository" sink="negate:true_or_false" />
  <s:link source="false:value" sink="s00_InitializeSemanticStorage:do_not_add_to_repository" />
  <s:link source="false:value" sink="s00_InitializeSemanticStorage:do_not_clear_tmp_rdf_file" />
  <s:link source="false:value" sink="s08_AddRdfToRepository:do_not_add_to_repository" />
  <s:link source="query" sink="s00_InitializeSemanticStorage:original_input_query" />
  <s:link source="query" sink="s01_AddBiologicalModelToSemanticModel:BioModelComment" />
  <s:link source="query" sink="s01_AddBiologicalModelToSemanticModel:ModelIdentifyingName" />
  <s:link source="query" sink="s02_AddOriginalQueryToSemanticModel:query" />
  <s:link source="negate:false_or_true" sink="s00_InitializeSemanticStorage:do_not_clear_repository" />
  <s:link source="p01_AddWorkflowToSemanticModel:AIDA_TextMiningWorkflowRun_instance" sink="p02_AddDocumentDiscoveryToSemanticModel:workflow_run_instance_uri" />
  <s:link source="p01_AddWorkflowToSemanticModel:AIDA_TextMiningWorkflowRun_instance" sink="p03_AddProteinDiscoveryToSemanticModel:workflow_run_instance_uri" />
  <s:link source="p02_AddDocumentDiscoveryToSemanticModel:AIDA_DocRetrProcessRun_instance" sink="s04_AddDocToSemanticModel:docretrieval_process_run_instance_uri" />
  <s:link source="p02_AddDocumentDiscoveryToSemanticModel:AIDA_DocRetrServiceRun_instance" sink="s04_AddDocToSemanticModel:docretrieval_service_run_instance_uri" />
  <s:link source="p03_AddProteinDiscoveryToSemanticModel:AIDA_NERProcessRun_instance" sink="CloneStringToList_NERprocessRunInstance:input" />
  <s:link source="p03_AddProteinDiscoveryToSemanticModel:AIDA_NERserviceRun_instance" sink="CloneStringToList_NERserviceRunInstance:input" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="p01_AddWorkflowToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="p02_AddDocumentDiscoveryToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="p03_AddProteinDiscoveryToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s01_AddBiologicalModelToSemanticModel:InstanceOntologyURL" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s02_AddOriginalQueryToSemanticModel:InstanceOntologyURL" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s03_AddExpandedQueryToSemanticModel:InstanceOntologyURL" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s03b_AddQueryProteinsToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s04_AddDocToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s05_AddDiscoveredProteinToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:BioAIDinstances_ontology_url" sink="s07_AddScoreToSemanticModel:instance_ontology_url" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="p01_AddWorkflowToSemanticModel:tmp_RDFdoc_fileref" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="p02_AddDocumentDiscoveryToSemanticModel:tmp_RDFdoc_fileref" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="p03_AddProteinDiscoveryToSemanticModel:tmp_RDFdoc_fileref" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s08_AddRdfToRepository:rdfFile_url" />
  <s:link source="s01_AddBiologicalModelToSemanticModel:biomodel_instance_uri" sink="s02_AddOriginalQueryToSemanticModel:model_instance_uri" />
  <s:link source="s01_AddBiologicalModelToSemanticModel:biomodel_instance_uri" sink="s03_AddExpandedQueryToSemanticModel:model_instance_uri" />
  <s:link source="s01_AddBiologicalModelToSemanticModel:biomodel_instance_uri" sink="s03b_AddQueryProteinsToSemanticModel:model_instance_uri" />
  <s:link source="s01_AddBiologicalModelToSemanticModel:biomodel_instance_uri" sink="s05_AddDiscoveredProteinToSemanticModel:model_instance_uri" />
  <s:link source="s02_AddOriginalQueryToSemanticModel:query_instance" sink="p01_AddWorkflowToSemanticModel:workflow_input" />
  <s:link source="s02_AddOriginalQueryToSemanticModel:query_instance" sink="p02_AddDocumentDiscoveryToSemanticModel:computation_input" />
  <s:link source="s02_AddOriginalQueryToSemanticModel:query_instance" sink="s03_AddExpandedQueryToSemanticModel:original_query_instance_uri" />
  <s:link source="s03_AddExpandedQueryToSemanticModel:query_instance" sink="s04_AddDocToSemanticModel:query_instance_uri" />
  <s:link source="s04_AddDocToSemanticModel:doc_instance_uri" sink="CloneStringToList_DocumentInstance:input" />
  <s:link source="s04_AddDocToSemanticModel:doc_instance_uri" sink="p03_AddProteinDiscoveryToSemanticModel:computation_input" />
  <s:link source="s04_AddDocToSemanticModel:doc_instance_uri" sink="s06_AddProteinRelationToSemanticModel:doc_instance" />
  <s:link source="02_RetrieveDocumentsFromMedline:pubmed_URL" sink="PubMed_URL" />
  <s:link source="03_ExtractProteins_UniProtValidation:protein_name" sink="Protein_name" />
  <s:link source="04_ExtractProteinRelations_HomoSapiens:relation" sink="Relation" />
  <s:link source="05_ScoreExtractedProteins:min_log_likelihood" sink="protein_discovery_score" />
  <s:link source="06_UniProtXrefURLs_iHopBYPASS:EntrezUniProtURL" sink="ProteinURL" />
  <s:link source="s00_InitializeSemanticStorage:BioAID_Repository_url" sink="BioAID_RDFrepository_URL" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="RDFtriples_doc_url" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s01_AddBiologicalModelToSemanticModel:RDF_doc_filename" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s02_AddOriginalQueryToSemanticModel:RDF_doc_filename" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s03_AddExpandedQueryToSemanticModel:RDF_doc_filename" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s03b_AddQueryProteinsToSemanticModel:tmp_rdf_output_fileref" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s04_AddDocToSemanticModel:rdf_output_doc_url" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s05_AddDiscoveredProteinToSemanticModel:tmp_rdf_output_fileref" />
  <s:link source="s00_InitializeSemanticStorage:RDFoutput_doc_url" sink="s07_AddScoreToSemanticModel:tmp_rdf_doc_ref" />
  <s:link source="s00_InitializeSemanticStorage:Rdf_NTriple_format" sink="s08_AddRdfToRepository:rdf_format" />
  <s:link source="s05_AddDiscoveredProteinToSemanticModel:protein_term_instance" sink="s07_AddScoreToSemanticModel:discovered_instance_uri" />
  <s:source name="query">
    <s:metadata>
      <s:mimeTypes>
        <s:mimeType>text/xml</s:mimeType>
      </s:mimeTypes>
      <s:description>Biological query, e.g. a protein of interest. See Lucene documentation for advanced queries (http://lucene.apache.org/)

Synonyms for protein names will be searched and added for terms within double quotes.</s:description>
    </s:metadata>
  </s:source>
  <s:source name="max_document_nr">
    <s:metadata>
      <s:description>limits the maximum number of hits search will produce. In Taverna 1 '100' works well while a 1000 and above is likely to halt Taverna 1 due to memory problems. This also depends on the memory setting for the java virtual machine by the client (usually your local Taverna).</s:description>
    </s:metadata>
  </s:source>
  <s:source name="aida_magic_word">
    <s:metadata>
      <s:description>A magic word is required to make use of the AIDA semantic repository for BioAID workflows. Please ask Scott Marshall (marshall@science.uva.nl) or Marco Roos (M.Roos1@uva.nl) for the magic word. NB: this semantic repository is for temporary data only. You should expect the repository to be cleared often and without warning.</s:description>
    </s:metadata>
  </s:source>
  <s:source name="clear_knowledge_repository">
    <s:metadata>
      <s:description>true 
if you would like the knowledge base (triple store) to be cleared and the proto-ontologies reloaded
false
otherwise</s:description>
    </s:metadata>
  </s:source>
  <s:sink name="ProteinURL" />
  <s:sink name="PubMed_URL" />
  <s:sink name="protein_discovery_score" />
  <s:sink name="Protein_name" />
  <s:sink name="Relation" />
  <s:sink name="RDFtriples_doc_url" />
  <s:sink name="BioAID_RDFrepository_URL" />
  <s:coordination name="s08_AddRdfToRepository_BLOCKON_s07_AddScoreToSemanticModel">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>s07_AddScoreToSemanticModel</s:target>
    </s:condition>
    <s:action>
      <s:target>s08_AddRdfToRepository</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="s06_AddProteinRelationToSemanticModel_BLOCKON_Fail">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Fail</s:target>
    </s:condition>
    <s:action>
      <s:target>s06_AddProteinRelationToSemanticModel</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="04_ExtractProteinRelations_HomoSapiens_BLOCKON_Fail">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>Fail</s:target>
    </s:condition>
    <s:action>
      <s:target>04_ExtractProteinRelations_HomoSapiens</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="06_UniProtXrefURLs_BLOCKON_05_ScoreExtractedProteins">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>05_ScoreExtractedProteins</s:target>
    </s:condition>
    <s:action>
      <s:target>06_UniProtXrefURLs_iHopBYPASS</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="01_ProcessQuery_BLOCKON_s00_InitializeSemanticStorage">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>s00_InitializeSemanticStorage</s:target>
    </s:condition>
    <s:action>
      <s:target>01_ProcessQuery</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="s03b_AddQueryProteinsToSemanticModel_BLOCKON_s03_AddExpandedQueryToSemanticModel">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>s03_AddExpandedQueryToSemanticModel</s:target>
    </s:condition>
    <s:action>
      <s:target>s03b_AddQueryProteinsToSemanticModel</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="s03_AddExpandedQueryToSemanticModel_BLOCKON_sw01_AddWorkflowToSemanticModel">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>p01_AddWorkflowToSemanticModel</s:target>
    </s:condition>
    <s:action>
      <s:target>s03_AddExpandedQueryToSemanticModel</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
  <s:coordination name="sw02_AddDocumentDiscoveryToSemanticModel_BLOCKON_s03b_AddQueryProteinsToSemanticModel">
    <s:condition>
      <s:state>Completed</s:state>
      <s:target>s03b_AddQueryProteinsToSemanticModel</s:target>
    </s:condition>
    <s:action>
      <s:target>p02_AddDocumentDiscoveryToSemanticModel</s:target>
      <s:statechange>
        <s:from>Scheduled</s:from>
        <s:to>Running</s:to>
      </s:statechange>
    </s:action>
  </s:coordination>
</s:scufl>

